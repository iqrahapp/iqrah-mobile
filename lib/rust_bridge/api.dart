// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'cbor_import.dart';
import 'exercises.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'repository.dart';

// These functions are ignored because they are not marked as `pub`: `build_mcq_from_word_instance`, `simple_map_to_exercise`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// One-time setup: initializes DB, imports graph, and syncs the default user.
/// Should be called on first app launch.
Future<String> setupDatabase({String? dbPath, required List<int> kgBytes}) =>
    RustLib.instance.api.crateApiSetupDatabase(
      dbPath: dbPath,
      kgBytes: kgBytes,
    );

Future<String> setupDatabaseInMemory({required List<int> kgBytes}) =>
    RustLib.instance.api.crateApiSetupDatabaseInMemory(kgBytes: kgBytes);

Future<List<Exercise>> getExercises({
  required String userId,
  required int limit,
  int? surahFilter,
}) => RustLib.instance.api.crateApiGetExercises(
  userId: userId,
  limit: limit,
  surahFilter: surahFilter,
);

Future<MemoryState> processReview({
  required String userId,
  required String nodeId,
  required ReviewGrade grade,
}) => RustLib.instance.api.crateApiProcessReview(
  userId: userId,
  nodeId: nodeId,
  grade: grade,
);

Future<DebugStats> getDebugStats({required String userId}) =>
    RustLib.instance.api.crateApiGetDebugStats(userId: userId);

Future<String> reseedDatabase() =>
    RustLib.instance.api.crateApiReseedDatabase();

Future<String> refreshPriorityScores({required String userId}) =>
    RustLib.instance.api.crateApiRefreshPriorityScores(userId: userId);

Future<List<ItemPreview>> getSessionPreview({
  required String userId,
  required int limit,
  int? surahFilter,
}) => RustLib.instance.api.crateApiGetSessionPreview(
  userId: userId,
  limit: limit,
  surahFilter: surahFilter,
);

/// Search node IDs by prefix (used for sandbox suggestions)
Future<List<NodeData>> searchNodes({
  required String query,
  required int limit,
}) => RustLib.instance.api.crateApiSearchNodes(query: query, limit: limit);

/// Fetch a single node with its metadata by ID
Future<NodeData?> fetchNodeWithMetadata({required String nodeId}) =>
    RustLib.instance.api.crateApiFetchNodeWithMetadata(nodeId: nodeId);

Future<List<Exercise>> getExercisesForNode({required String nodeId}) =>
    RustLib.instance.api.crateApiGetExercisesForNode(nodeId: nodeId);

Future<List<SurahInfo>> getAvailableSurahs() =>
    RustLib.instance.api.crateApiGetAvailableSurahs();

class SurahInfo {
  final int number;
  final String name;

  const SurahInfo({required this.number, required this.name});

  @override
  int get hashCode => number.hashCode ^ name.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SurahInfo &&
          runtimeType == other.runtimeType &&
          number == other.number &&
          name == other.name;
}

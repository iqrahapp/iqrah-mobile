// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `app`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// One-time setup: initializes databases and imports graph
Future<String> setupDatabase({
  required String contentDbPath,
  required String userDbPath,
  required List<int> kgBytes,
}) => RustLib.instance.api.crateApiSetupDatabase(
  contentDbPath: contentDbPath,
  userDbPath: userDbPath,
  kgBytes: kgBytes,
);

/// Setup with in-memory databases (for testing)
Future<String> setupDatabaseInMemory({required List<int> kgBytes}) =>
    RustLib.instance.api.crateApiSetupDatabaseInMemory(kgBytes: kgBytes);

/// Get exercises for review session
Future<List<ExerciseDto>> getExercises({
  required String userId,
  required int limit,
  int? surahFilter,
  required bool isHighYield,
}) => RustLib.instance.api.crateApiGetExercises(
  userId: userId,
  limit: limit,
  surahFilter: surahFilter,
  isHighYield: isHighYield,
);

/// Generate exercise using modern enum-based architecture (V2)
///
/// This returns lightweight ExerciseData containing only keys/IDs.
/// Flutter can then fetch content based on user preferences (Tajweed, Indopak, etc.)
Future<ExerciseData> generateExerciseV2({required String nodeId}) =>
    RustLib.instance.api.crateApiGenerateExerciseV2(nodeId: nodeId);

/// Process a review
Future<String> processReview({
  required String userId,
  required String nodeId,
  required int grade,
}) => RustLib.instance.api.crateApiProcessReview(
  userId: userId,
  nodeId: nodeId,
  grade: grade,
);

/// Get dashboard stats
Future<DashboardStatsDto> getDashboardStats({required String userId}) =>
    RustLib.instance.api.crateApiGetDashboardStats(userId: userId);

/// Get debug stats
Future<DebugStatsDto> getDebugStats({required String userId}) =>
    RustLib.instance.api.crateApiGetDebugStats(userId: userId);

/// Reset user progress
Future<String> reseedDatabase({required String userId}) =>
    RustLib.instance.api.crateApiReseedDatabase(userId: userId);

/// Get session preview
Future<List<SessionPreviewDto>> getSessionPreview({
  required String userId,
  required int limit,
  required bool isHighYield,
}) => RustLib.instance.api.crateApiGetSessionPreview(
  userId: userId,
  limit: limit,
  isHighYield: isHighYield,
);

/// Clear session
Future<String> clearSession() => RustLib.instance.api.crateApiClearSession();

/// Search nodes
Future<List<NodeSearchDto>> searchNodes({
  required String query,
  required int limit,
}) => RustLib.instance.api.crateApiSearchNodes(query: query, limit: limit);

/// Get available surahs
Future<List<SurahInfo>> getAvailableSurahs() =>
    RustLib.instance.api.crateApiGetAvailableSurahs();

/// Get all available languages
Future<List<LanguageDto>> getLanguages() =>
    RustLib.instance.api.crateApiGetLanguages();

/// Get all translators for a given language
Future<List<TranslatorDto>> getTranslatorsForLanguage({
  required String languageCode,
}) => RustLib.instance.api.crateApiGetTranslatorsForLanguage(
  languageCode: languageCode,
);

/// Get a specific translator by ID
Future<TranslatorDto?> getTranslator({required int translatorId}) =>
    RustLib.instance.api.crateApiGetTranslator(translatorId: translatorId);

/// Get user's preferred translator ID
Future<int> getPreferredTranslatorId() =>
    RustLib.instance.api.crateApiGetPreferredTranslatorId();

/// Set user's preferred translator ID
Future<String> setPreferredTranslatorId({required int translatorId}) => RustLib
    .instance
    .api
    .crateApiSetPreferredTranslatorId(translatorId: translatorId);

/// Get verse translation for a specific translator
Future<String?> getVerseTranslationByTranslator({
  required String verseKey,
  required int translatorId,
}) => RustLib.instance.api.crateApiGetVerseTranslationByTranslator(
  verseKey: verseKey,
  translatorId: translatorId,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AppState>>
abstract class AppState implements RustOpaqueInterface {
  ArcContentRepository get contentRepo;

  ArcExerciseService get exerciseService;

  ArcLearningService get learningService;

  ArcSessionService get sessionService;

  ArcUserRepository get userRepo;

  set contentRepo(ArcContentRepository contentRepo);

  set exerciseService(ArcExerciseService exerciseService);

  set learningService(ArcLearningService learningService);

  set sessionService(ArcSessionService sessionService);

  set userRepo(ArcUserRepository userRepo);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < ExerciseService >>>
abstract class ArcExerciseService implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < LearningService >>>
abstract class ArcLearningService implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < SessionService >>>
abstract class ArcSessionService implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn ContentRepository >>>
abstract class ArcContentRepository implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn UserRepository >>>
abstract class ArcUserRepository implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExerciseData>>
abstract class ExerciseData implements RustOpaqueInterface {}

class DashboardStatsDto {
  final int reviewsToday;
  final int streakDays;
  final int dueCount;

  const DashboardStatsDto({
    required this.reviewsToday,
    required this.streakDays,
    required this.dueCount,
  });

  @override
  int get hashCode =>
      reviewsToday.hashCode ^ streakDays.hashCode ^ dueCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DashboardStatsDto &&
          runtimeType == other.runtimeType &&
          reviewsToday == other.reviewsToday &&
          streakDays == other.streakDays &&
          dueCount == other.dueCount;
}

class DebugStatsDto {
  final int totalNodesCount;
  final int totalEdgesCount;
  final int dueCount;

  const DebugStatsDto({
    required this.totalNodesCount,
    required this.totalEdgesCount,
    required this.dueCount,
  });

  @override
  int get hashCode =>
      totalNodesCount.hashCode ^ totalEdgesCount.hashCode ^ dueCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DebugStatsDto &&
          runtimeType == other.runtimeType &&
          totalNodesCount == other.totalNodesCount &&
          totalEdgesCount == other.totalEdgesCount &&
          dueCount == other.dueCount;
}

class ExerciseDto {
  final String nodeId;
  final String question;
  final String answer;
  final String nodeType;
  final String? translatorName;

  const ExerciseDto({
    required this.nodeId,
    required this.question,
    required this.answer,
    required this.nodeType,
    this.translatorName,
  });

  @override
  int get hashCode =>
      nodeId.hashCode ^
      question.hashCode ^
      answer.hashCode ^
      nodeType.hashCode ^
      translatorName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExerciseDto &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          question == other.question &&
          answer == other.answer &&
          nodeType == other.nodeType &&
          translatorName == other.translatorName;
}

class LanguageDto {
  final String code;
  final String englishName;
  final String nativeName;
  final String direction;

  const LanguageDto({
    required this.code,
    required this.englishName,
    required this.nativeName,
    required this.direction,
  });

  @override
  int get hashCode =>
      code.hashCode ^
      englishName.hashCode ^
      nativeName.hashCode ^
      direction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LanguageDto &&
          runtimeType == other.runtimeType &&
          code == other.code &&
          englishName == other.englishName &&
          nativeName == other.nativeName &&
          direction == other.direction;
}

class NodeSearchDto {
  final String nodeId;
  final String nodeType;
  final String preview;

  const NodeSearchDto({
    required this.nodeId,
    required this.nodeType,
    required this.preview,
  });

  @override
  int get hashCode => nodeId.hashCode ^ nodeType.hashCode ^ preview.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeSearchDto &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          nodeType == other.nodeType &&
          preview == other.preview;
}

class SessionPreviewDto {
  final String nodeId;
  final String nodeType;
  final String previewText;
  final double energy;
  final double priorityScore;

  const SessionPreviewDto({
    required this.nodeId,
    required this.nodeType,
    required this.previewText,
    required this.energy,
    required this.priorityScore,
  });

  @override
  int get hashCode =>
      nodeId.hashCode ^
      nodeType.hashCode ^
      previewText.hashCode ^
      energy.hashCode ^
      priorityScore.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionPreviewDto &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          nodeType == other.nodeType &&
          previewText == other.previewText &&
          energy == other.energy &&
          priorityScore == other.priorityScore;
}

class SurahInfo {
  final int number;
  final String name;

  const SurahInfo({required this.number, required this.name});

  @override
  int get hashCode => number.hashCode ^ name.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SurahInfo &&
          runtimeType == other.runtimeType &&
          number == other.number &&
          name == other.name;
}

class TranslatorDto {
  final int id;
  final String slug;
  final String fullName;
  final String languageCode;
  final String? description;
  final String? license;

  const TranslatorDto({
    required this.id,
    required this.slug,
    required this.fullName,
    required this.languageCode,
    this.description,
    this.license,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      slug.hashCode ^
      fullName.hashCode ^
      languageCode.hashCode ^
      description.hashCode ^
      license.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TranslatorDto &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          slug == other.slug &&
          fullName == other.fullName &&
          languageCode == other.languageCode &&
          description == other.description &&
          license == other.license;
}

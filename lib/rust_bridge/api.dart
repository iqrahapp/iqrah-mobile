// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'api.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `app`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ExerciseDto`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`

/// One-time setup: initializes databases and imports graph
Future<String> setupDatabase({
  required String contentDbPath,
  required String userDbPath,
  required List<int> kgBytes,
}) => RustLib.instance.api.crateApiSetupDatabase(
  contentDbPath: contentDbPath,
  userDbPath: userDbPath,
  kgBytes: kgBytes,
);

/// Setup with in-memory databases (for testing)
Future<String> setupDatabaseInMemory({required List<int> kgBytes}) =>
    RustLib.instance.api.crateApiSetupDatabaseInMemory(kgBytes: kgBytes);

/// Get exercises for review session
Future<List<ExerciseDataDto>> getExercises({
  required String userId,
  required int limit,
  int? surahFilter,
  required bool isHighYield,
}) => RustLib.instance.api.crateApiGetExercises(
  userId: userId,
  limit: limit,
  surahFilter: surahFilter,
  isHighYield: isHighYield,
);

/// Get exercises for a specific node (Sandbox/Preview)
Future<List<ExerciseDataDto>> getExercisesForNode({required String nodeId}) =>
    RustLib.instance.api.crateApiGetExercisesForNode(nodeId: nodeId);

/// Fetch node with metadata for Sandbox
Future<NodeData?> fetchNodeWithMetadata({required String nodeId}) =>
    RustLib.instance.api.crateApiFetchNodeWithMetadata(nodeId: nodeId);

/// Generate exercise using modern enum-based architecture (V2)
///
/// This returns lightweight ExerciseData containing only keys/IDs.
/// Flutter can then fetch content based on user preferences (Tajweed, Indopak, etc.)
Future<ExerciseDataDto> generateExerciseV2({required String nodeId}) =>
    RustLib.instance.api.crateApiGenerateExerciseV2(nodeId: nodeId);

/// Get verse content
Future<VerseDto?> getVerse({required String verseKey}) =>
    RustLib.instance.api.crateApiGetVerse(verseKey: verseKey);

/// Get word content
Future<WordDto?> getWord({required int wordId}) =>
    RustLib.instance.api.crateApiGetWord(wordId: wordId);

/// Get all words for a verse
Future<List<WordDto>> getWordsForVerse({required String verseKey}) =>
    RustLib.instance.api.crateApiGetWordsForVerse(verseKey: verseKey);

/// Get word translation
Future<String?> getWordTranslation({
  required int wordId,
  required int translatorId,
}) => RustLib.instance.api.crateApiGetWordTranslation(
  wordId: wordId,
  translatorId: translatorId,
);

/// Process a review
Future<String> processReview({
  required String userId,
  required String nodeId,
  required int grade,
}) => RustLib.instance.api.crateApiProcessReview(
  userId: userId,
  nodeId: nodeId,
  grade: grade,
);

/// Get dashboard stats
Future<DashboardStatsDto> getDashboardStats({required String userId}) =>
    RustLib.instance.api.crateApiGetDashboardStats(userId: userId);

/// Get debug stats
Future<DebugStatsDto> getDebugStats({required String userId}) =>
    RustLib.instance.api.crateApiGetDebugStats(userId: userId);

/// Reset user progress
Future<String> reseedDatabase({required String userId}) =>
    RustLib.instance.api.crateApiReseedDatabase(userId: userId);

/// Get session preview
Future<List<SessionPreviewDto>> getSessionPreview({
  required String userId,
  required int limit,
  required bool isHighYield,
}) => RustLib.instance.api.crateApiGetSessionPreview(
  userId: userId,
  limit: limit,
  isHighYield: isHighYield,
);

/// Clear session
Future<String> clearSession() => RustLib.instance.api.crateApiClearSession();

/// Search nodes
Future<List<NodeSearchDto>> searchNodes({
  required String query,
  required int limit,
}) => RustLib.instance.api.crateApiSearchNodes(query: query, limit: limit);

/// Get available surahs
Future<List<SurahInfo>> getAvailableSurahs() =>
    RustLib.instance.api.crateApiGetAvailableSurahs();

/// Get all available languages
Future<List<LanguageDto>> getLanguages() =>
    RustLib.instance.api.crateApiGetLanguages();

/// Get all translators for a given language
Future<List<TranslatorDto>> getTranslatorsForLanguage({
  required String languageCode,
}) => RustLib.instance.api.crateApiGetTranslatorsForLanguage(
  languageCode: languageCode,
);

/// Get a specific translator by ID
Future<TranslatorDto?> getTranslator({required int translatorId}) =>
    RustLib.instance.api.crateApiGetTranslator(translatorId: translatorId);

/// Get user's preferred translator ID
Future<int> getPreferredTranslatorId() =>
    RustLib.instance.api.crateApiGetPreferredTranslatorId();

/// Set user's preferred translator ID
Future<String> setPreferredTranslatorId({required int translatorId}) => RustLib
    .instance
    .api
    .crateApiSetPreferredTranslatorId(translatorId: translatorId);

/// Get verse translation for a specific translator
Future<String?> getVerseTranslationByTranslator({
  required String verseKey,
  required int translatorId,
}) => RustLib.instance.api.crateApiGetVerseTranslationByTranslator(
  verseKey: verseKey,
  translatorId: translatorId,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AppState>>
abstract class AppState implements RustOpaqueInterface {
  ArcContentRepository get contentRepo;

  ArcExerciseService get exerciseService;

  ArcLearningService get learningService;

  ArcSessionService get sessionService;

  ArcUserRepository get userRepo;

  set contentRepo(ArcContentRepository contentRepo);

  set exerciseService(ArcExerciseService exerciseService);

  set learningService(ArcLearningService learningService);

  set sessionService(ArcSessionService sessionService);

  set userRepo(ArcUserRepository userRepo);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < ExerciseService >>>
abstract class ArcExerciseService implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < LearningService >>>
abstract class ArcLearningService implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < SessionService >>>
abstract class ArcSessionService implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn ContentRepository >>>
abstract class ArcContentRepository implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn UserRepository >>>
abstract class ArcUserRepository implements RustOpaqueInterface {}

class DashboardStatsDto {
  final int reviewsToday;
  final int streakDays;
  final int dueCount;

  const DashboardStatsDto({
    required this.reviewsToday,
    required this.streakDays,
    required this.dueCount,
  });

  @override
  int get hashCode =>
      reviewsToday.hashCode ^ streakDays.hashCode ^ dueCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DashboardStatsDto &&
          runtimeType == other.runtimeType &&
          reviewsToday == other.reviewsToday &&
          streakDays == other.streakDays &&
          dueCount == other.dueCount;
}

class DebugStatsDto {
  final int totalNodesCount;
  final int totalEdgesCount;
  final int dueCount;

  const DebugStatsDto({
    required this.totalNodesCount,
    required this.totalEdgesCount,
    required this.dueCount,
  });

  @override
  int get hashCode =>
      totalNodesCount.hashCode ^ totalEdgesCount.hashCode ^ dueCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DebugStatsDto &&
          runtimeType == other.runtimeType &&
          totalNodesCount == other.totalNodesCount &&
          totalEdgesCount == other.totalEdgesCount &&
          dueCount == other.dueCount;
}

@freezed
sealed class ExerciseDataDto with _$ExerciseDataDto {
  const ExerciseDataDto._();

  const factory ExerciseDataDto.memorization({required String nodeId}) =
      ExerciseDataDto_Memorization;
  const factory ExerciseDataDto.mcqArToEn({
    required String nodeId,
    required List<String> distractorNodeIds,
  }) = ExerciseDataDto_McqArToEn;
  const factory ExerciseDataDto.mcqEnToAr({
    required String nodeId,
    required List<String> distractorNodeIds,
  }) = ExerciseDataDto_McqEnToAr;
  const factory ExerciseDataDto.translation({required String nodeId}) =
      ExerciseDataDto_Translation;
  const factory ExerciseDataDto.contextualTranslation({
    required String nodeId,
    required String verseKey,
  }) = ExerciseDataDto_ContextualTranslation;
  const factory ExerciseDataDto.clozeDeletion({
    required String nodeId,
    required int blankPosition,
  }) = ExerciseDataDto_ClozeDeletion;
  const factory ExerciseDataDto.firstLetterHint({
    required String nodeId,
    required int wordPosition,
  }) = ExerciseDataDto_FirstLetterHint;
  const factory ExerciseDataDto.missingWordMcq({
    required String nodeId,
    required int blankPosition,
    required List<String> distractorNodeIds,
  }) = ExerciseDataDto_MissingWordMcq;
  const factory ExerciseDataDto.nextWordMcq({
    required String nodeId,
    required int contextPosition,
    required List<String> distractorNodeIds,
  }) = ExerciseDataDto_NextWordMcq;
  const factory ExerciseDataDto.fullVerseInput({required String nodeId}) =
      ExerciseDataDto_FullVerseInput;
  const factory ExerciseDataDto.ayahChain({
    required String nodeId,
    required List<String> verseKeys,
    required BigInt currentIndex,
    required BigInt completedCount,
  }) = ExerciseDataDto_AyahChain;
  const factory ExerciseDataDto.findMistake({
    required String nodeId,
    required int mistakePosition,
    required String correctWordNodeId,
    required String incorrectWordNodeId,
  }) = ExerciseDataDto_FindMistake;
  const factory ExerciseDataDto.ayahSequence({
    required String nodeId,
    required List<String> correctSequence,
  }) = ExerciseDataDto_AyahSequence;
  const factory ExerciseDataDto.identifyRoot({
    required String nodeId,
    required String root,
  }) = ExerciseDataDto_IdentifyRoot;
  const factory ExerciseDataDto.reverseCloze({
    required String nodeId,
    required int blankPosition,
  }) = ExerciseDataDto_ReverseCloze;
  const factory ExerciseDataDto.translatePhrase({
    required String nodeId,
    required int translatorId,
  }) = ExerciseDataDto_TranslatePhrase;
  const factory ExerciseDataDto.posTagging({
    required String nodeId,
    required String correctPos,
    required List<String> options,
  }) = ExerciseDataDto_PosTagging;
  const factory ExerciseDataDto.crossVerseConnection({
    required String nodeId,
    required List<String> relatedVerseIds,
    required String connectionTheme,
  }) = ExerciseDataDto_CrossVerseConnection;
}

class LanguageDto {
  final String code;
  final String englishName;
  final String nativeName;
  final String direction;

  const LanguageDto({
    required this.code,
    required this.englishName,
    required this.nativeName,
    required this.direction,
  });

  @override
  int get hashCode =>
      code.hashCode ^
      englishName.hashCode ^
      nativeName.hashCode ^
      direction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LanguageDto &&
          runtimeType == other.runtimeType &&
          code == other.code &&
          englishName == other.englishName &&
          nativeName == other.nativeName &&
          direction == other.direction;
}

class NodeData {
  final String id;
  final String nodeType;
  final Map<String, String> metadata;

  const NodeData({
    required this.id,
    required this.nodeType,
    required this.metadata,
  });

  @override
  int get hashCode => id.hashCode ^ nodeType.hashCode ^ metadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeData &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          nodeType == other.nodeType &&
          metadata == other.metadata;
}

class NodeSearchDto {
  final String nodeId;
  final String nodeType;
  final String preview;

  const NodeSearchDto({
    required this.nodeId,
    required this.nodeType,
    required this.preview,
  });

  @override
  int get hashCode => nodeId.hashCode ^ nodeType.hashCode ^ preview.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeSearchDto &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          nodeType == other.nodeType &&
          preview == other.preview;
}

class SessionPreviewDto {
  final String nodeId;
  final String nodeType;
  final String previewText;
  final double energy;
  final double priorityScore;

  const SessionPreviewDto({
    required this.nodeId,
    required this.nodeType,
    required this.previewText,
    required this.energy,
    required this.priorityScore,
  });

  @override
  int get hashCode =>
      nodeId.hashCode ^
      nodeType.hashCode ^
      previewText.hashCode ^
      energy.hashCode ^
      priorityScore.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionPreviewDto &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          nodeType == other.nodeType &&
          previewText == other.previewText &&
          energy == other.energy &&
          priorityScore == other.priorityScore;
}

class SurahInfo {
  final int number;
  final String name;

  const SurahInfo({required this.number, required this.name});

  @override
  int get hashCode => number.hashCode ^ name.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SurahInfo &&
          runtimeType == other.runtimeType &&
          number == other.number &&
          name == other.name;
}

class TranslatorDto {
  final int id;
  final String slug;
  final String fullName;
  final String languageCode;
  final String? description;
  final String? license;

  const TranslatorDto({
    required this.id,
    required this.slug,
    required this.fullName,
    required this.languageCode,
    this.description,
    this.license,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      slug.hashCode ^
      fullName.hashCode ^
      languageCode.hashCode ^
      description.hashCode ^
      license.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TranslatorDto &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          slug == other.slug &&
          fullName == other.fullName &&
          languageCode == other.languageCode &&
          description == other.description &&
          license == other.license;
}

class VerseDto {
  final String key;
  final String textUthmani;
  final int chapterNumber;
  final int verseNumber;

  const VerseDto({
    required this.key,
    required this.textUthmani,
    required this.chapterNumber,
    required this.verseNumber,
  });

  @override
  int get hashCode =>
      key.hashCode ^
      textUthmani.hashCode ^
      chapterNumber.hashCode ^
      verseNumber.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VerseDto &&
          runtimeType == other.runtimeType &&
          key == other.key &&
          textUthmani == other.textUthmani &&
          chapterNumber == other.chapterNumber &&
          verseNumber == other.verseNumber;
}

class WordDto {
  final int id;
  final String textUthmani;
  final String verseKey;
  final int position;

  const WordDto({
    required this.id,
    required this.textUthmani,
    required this.verseKey,
    required this.position,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      textUthmani.hashCode ^
      verseKey.hashCode ^
      position.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WordDto &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          textUthmani == other.textUthmani &&
          verseKey == other.verseKey &&
          position == other.position;
}

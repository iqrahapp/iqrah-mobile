// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'api.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `app`, `populate_nodes_from_content`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ExerciseDto`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

/// One-time setup: initializes databases and imports graph
Future<String> setupDatabase({
  required String contentDbPath,
  required String userDbPath,
  required List<int> kgBytes,
}) => RustLib.instance.api.crateApiSetupDatabase(
  contentDbPath: contentDbPath,
  userDbPath: userDbPath,
  kgBytes: kgBytes,
);

/// Setup with in-memory databases (for testing)
Future<String> setupDatabaseInMemory({required List<int> kgBytes}) =>
    RustLib.instance.api.crateApiSetupDatabaseInMemory(kgBytes: kgBytes);

/// Get exercises for review session
Future<List<ExerciseDataDto>> getExercises({
  required String userId,
  required int limit,
  int? surahFilter,
  required bool isHighYield,
}) => RustLib.instance.api.crateApiGetExercises(
  userId: userId,
  limit: limit,
  surahFilter: surahFilter,
  isHighYield: isHighYield,
);

/// Start a new session and persist its state
Future<SessionDto> startSession({
  required String userId,
  required String goalId,
}) => RustLib.instance.api.crateApiStartSession(userId: userId, goalId: goalId);

/// Get the active (incomplete) session for a user
Future<SessionDto?> getActiveSession({required String userId}) =>
    RustLib.instance.api.crateApiGetActiveSession(userId: userId);

/// Get the next session item (exercise) to present
Future<SessionItemDto?> getNextSessionItem({required String sessionId}) =>
    RustLib.instance.api.crateApiGetNextSessionItem(sessionId: sessionId);

/// Submit a completed session item
Future<String> submitSessionItem({
  required String sessionId,
  required String nodeId,
  required String exerciseType,
  required int grade,
  required BigInt durationMs,
}) => RustLib.instance.api.crateApiSubmitSessionItem(
  sessionId: sessionId,
  nodeId: nodeId,
  exerciseType: exerciseType,
  grade: grade,
  durationMs: durationMs,
);

/// Complete a session and return summary
Future<SessionSummaryDto> completeSession({required String sessionId}) =>
    RustLib.instance.api.crateApiCompleteSession(sessionId: sessionId);

/// Get exercises for a specific node (Sandbox/Preview)
Future<List<ExerciseDataDto>> getExercisesForNode({required String nodeId}) =>
    RustLib.instance.api.crateApiGetExercisesForNode(nodeId: nodeId);

/// Fetch node with metadata for Sandbox
Future<NodeData?> fetchNodeWithMetadata({required String nodeId}) =>
    RustLib.instance.api.crateApiFetchNodeWithMetadata(nodeId: nodeId);

/// Generate exercise using modern enum-based architecture (V2)
///
/// This returns lightweight ExerciseData containing only keys/IDs.
/// Flutter can then fetch content based on user preferences (Tajweed, Indopak, etc.)
Future<ExerciseDataDto> generateExerciseV2({required String nodeId}) =>
    RustLib.instance.api.crateApiGenerateExerciseV2(nodeId: nodeId);

/// Get verse content
Future<VerseDto?> getVerse({required String verseKey}) =>
    RustLib.instance.api.crateApiGetVerse(verseKey: verseKey);

/// Get word content
Future<WordDto?> getWord({required int wordId}) =>
    RustLib.instance.api.crateApiGetWord(wordId: wordId);

/// Get all words for a verse
Future<List<WordDto>> getWordsForVerse({required String verseKey}) =>
    RustLib.instance.api.crateApiGetWordsForVerse(verseKey: verseKey);

/// Get word at specific position in a verse (resolves WORD_INSTANCE nodes)
Future<WordDto?> getWordAtPosition({
  required int chapter,
  required int verse,
  required int position,
}) => RustLib.instance.api.crateApiGetWordAtPosition(
  chapter: chapter,
  verse: verse,
  position: position,
);

/// Get word translation
Future<String?> getWordTranslation({
  required int wordId,
  required int translatorId,
}) => RustLib.instance.api.crateApiGetWordTranslation(
  wordId: wordId,
  translatorId: translatorId,
);

/// Process a review
Future<String> processReview({
  required String userId,
  required String nodeId,
  required int grade,
}) => RustLib.instance.api.crateApiProcessReview(
  userId: userId,
  nodeId: nodeId,
  grade: grade,
);

/// Get dashboard stats
Future<DashboardStatsDto> getDashboardStats({required String userId}) =>
    RustLib.instance.api.crateApiGetDashboardStats(userId: userId);

/// Get debug stats
Future<DebugStatsDto> getDebugStats({required String userId}) =>
    RustLib.instance.api.crateApiGetDebugStats(userId: userId);

/// Close database pools (debug only)
/// After calling this, the app must be restarted to reinitialize databases.
Future<String> closeDatabases() =>
    RustLib.instance.api.crateApiCloseDatabases();

/// Get database health status with table counts and issues
Future<DbHealthDto> getDbHealth() => RustLib.instance.api.crateApiGetDbHealth();

/// Reset user progress
Future<String> reseedDatabase({required String userId}) =>
    RustLib.instance.api.crateApiReseedDatabase(userId: userId);

/// Get session preview
Future<List<SessionPreviewDto>> getSessionPreview({
  required String userId,
  required int limit,
  required bool isHighYield,
}) => RustLib.instance.api.crateApiGetSessionPreview(
  userId: userId,
  limit: limit,
  isHighYield: isHighYield,
);

/// Clear session
Future<String> clearSession() => RustLib.instance.api.crateApiClearSession();

/// Search nodes
Future<List<NodeSearchDto>> searchNodes({
  required String query,
  required int limit,
}) => RustLib.instance.api.crateApiSearchNodes(query: query, limit: limit);

/// Get available surahs
Future<List<SurahInfo>> getAvailableSurahs() =>
    RustLib.instance.api.crateApiGetAvailableSurahs();

/// Get all available languages
Future<List<LanguageDto>> getLanguages() =>
    RustLib.instance.api.crateApiGetLanguages();

/// Get all translators for a given language
Future<List<TranslatorDto>> getTranslatorsForLanguage({
  required String languageCode,
}) => RustLib.instance.api.crateApiGetTranslatorsForLanguage(
  languageCode: languageCode,
);

/// Get a specific translator by ID
Future<TranslatorDto?> getTranslator({required int translatorId}) =>
    RustLib.instance.api.crateApiGetTranslator(translatorId: translatorId);

/// Get user's preferred translator ID
Future<int> getPreferredTranslatorId() =>
    RustLib.instance.api.crateApiGetPreferredTranslatorId();

/// Set user's preferred translator ID
Future<String> setPreferredTranslatorId({required int translatorId}) => RustLib
    .instance
    .api
    .crateApiSetPreferredTranslatorId(translatorId: translatorId);

/// Get verse translation for a specific translator
Future<String?> getVerseTranslationByTranslator({
  required String verseKey,
  required int translatorId,
}) => RustLib.instance.api.crateApiGetVerseTranslationByTranslator(
  verseKey: verseKey,
  translatorId: translatorId,
);

/// List available content packages (optionally filtered)
Future<List<ContentPackageDto>> getAvailablePackages({
  String? packageType,
  String? languageCode,
}) => RustLib.instance.api.crateApiGetAvailablePackages(
  packageType: packageType,
  languageCode: languageCode,
);

/// List installed content packages
Future<List<InstalledPackageDto>> getInstalledPackages() =>
    RustLib.instance.api.crateApiGetInstalledPackages();

/// Enable an installed package
Future<String> enablePackage({required String packageId}) =>
    RustLib.instance.api.crateApiEnablePackage(packageId: packageId);

/// Disable an installed package
Future<String> disablePackage({required String packageId}) =>
    RustLib.instance.api.crateApiDisablePackage(packageId: packageId);

/// Install a translation package from raw bytes
Future<String> installTranslationPackFromBytes({
  required String packageId,
  required List<int> bytes,
}) => RustLib.instance.api.crateApiInstallTranslationPackFromBytes(
  packageId: packageId,
  bytes: bytes,
);

/// Start a new Echo Recall session
///
/// Fetches all words from the specified ayahs, retrieves their current
/// energy levels, and calculates initial visibility.
Future<EchoRecallStateDto> startEchoRecall({
  required String userId,
  required List<String> ayahNodeIds,
}) => RustLib.instance.api.crateApiStartEchoRecall(
  userId: userId,
  ayahNodeIds: ayahNodeIds,
);

/// Submit a word recall and get updated state
///
/// Calculates energy change based on recall time, updates the word's
/// energy and visibility, and recalculates neighbor visibility.
///
/// Note: user_id and ayah_node_ids are included for API consistency but
/// the stateless pattern means they're only used for context/logging.
Future<EchoRecallStateDto> submitEchoRecall({
  required String userId,
  required List<String> ayahNodeIds,
  required EchoRecallStateDto state,
  required String wordNodeId,
  required int recallTimeMs,
}) => RustLib.instance.api.crateApiSubmitEchoRecall(
  userId: userId,
  ayahNodeIds: ayahNodeIds,
  state: state,
  wordNodeId: wordNodeId,
  recallTimeMs: recallTimeMs,
);

/// Get statistics for an Echo Recall session
Future<EchoRecallStatsDto> echoRecallStats({
  required EchoRecallStateDto state,
}) => RustLib.instance.api.crateApiEchoRecallStats(state: state);

/// Finalize an Echo Recall session
///
/// Persists energy updates to the user's memory states and emits telemetry.
/// Accepts per-word timing metrics for detailed analytics.
Future<EchoRecallResultDto> finalizeEchoRecall({
  required String userId,
  required EchoRecallStateDto state,
  required EchoRecallMetricsDto metrics,
}) => RustLib.instance.api.crateApiFinalizeEchoRecall(
  userId: userId,
  state: state,
  metrics: metrics,
);

/// Drain all pending telemetry events as JSON strings
/// Call periodically from Dart (e.g. every 30s or on app background)
Future<List<String>> drainTelemetryEvents() =>
    RustLib.instance.api.crateApiDrainTelemetryEvents();

/// Get count of pending telemetry events
Future<int> getTelemetryEventCount() =>
    RustLib.instance.api.crateApiGetTelemetryEventCount();

/// Debug: manually emit a test event (dev only)
Future<String> debugEmitTestEvent() =>
    RustLib.instance.api.crateApiDebugEmitTestEvent();

/// Get energy snapshot for a node including neighbor energies
Future<EnergySnapshotDto> getEnergySnapshot({
  required String userId,
  required String nodeId,
}) => RustLib.instance.api.crateApiGetEnergySnapshot(
  userId: userId,
  nodeId: nodeId,
);

/// Simulate energy propagation without persisting changes
Future<PropagationResultDto> simulatePropagation({
  required String userId,
  required String nodeId,
  required double energyDelta,
}) => RustLib.instance.api.crateApiSimulatePropagation(
  userId: userId,
  nodeId: nodeId,
  energyDelta: energyDelta,
);

/// Parse a verse range string into individual node IDs
/// Supports: "1:1-1:7" or "1:1-7" (shorthand for same chapter)
Future<List<String>> parseNodeRange({required String range}) =>
    RustLib.instance.api.crateApiParseNodeRange(range: range);

/// Query nodes with filters (type, energy range)
Future<List<NodeSearchDto>> queryNodesFiltered({
  required String userId,
  required NodeFilterDto filter,
  required int limit,
}) => RustLib.instance.api.crateApiQueryNodesFiltered(
  userId: userId,
  filter: filter,
  limit: limit,
);

/// Execute a debug SQL query (debug builds only)
/// Only SELECT queries are allowed for safety
Future<DbQueryResultDto> executeDebugQuery({required String sql}) =>
    RustLib.instance.api.crateApiExecuteDebugQuery(sql: sql);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AppState>>
abstract class AppState implements RustOpaqueInterface {
  ArcContentRepository get contentRepo;

  ArcExerciseService get exerciseService;

  ArcLearningService get learningService;

  ArcSessionService get sessionService;

  ArcUserRepository get userRepo;

  set contentRepo(ArcContentRepository contentRepo);

  set exerciseService(ArcExerciseService exerciseService);

  set learningService(ArcLearningService learningService);

  set sessionService(ArcSessionService sessionService);

  set userRepo(ArcUserRepository userRepo);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < ExerciseService >>>
abstract class ArcExerciseService implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < LearningService >>>
abstract class ArcLearningService implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < SessionService >>>
abstract class ArcSessionService implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn ContentRepository >>>
abstract class ArcContentRepository implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < dyn UserRepository >>>
abstract class ArcUserRepository implements RustOpaqueInterface {}

class ContentPackageDto {
  final String packageId;
  final String packageType;
  final String name;
  final String? languageCode;
  final String? author;
  final String version;
  final String? description;
  final PlatformInt64? fileSize;
  final String? downloadUrl;
  final String? checksum;
  final String? license;

  const ContentPackageDto({
    required this.packageId,
    required this.packageType,
    required this.name,
    this.languageCode,
    this.author,
    required this.version,
    this.description,
    this.fileSize,
    this.downloadUrl,
    this.checksum,
    this.license,
  });

  @override
  int get hashCode =>
      packageId.hashCode ^
      packageType.hashCode ^
      name.hashCode ^
      languageCode.hashCode ^
      author.hashCode ^
      version.hashCode ^
      description.hashCode ^
      fileSize.hashCode ^
      downloadUrl.hashCode ^
      checksum.hashCode ^
      license.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ContentPackageDto &&
          runtimeType == other.runtimeType &&
          packageId == other.packageId &&
          packageType == other.packageType &&
          name == other.name &&
          languageCode == other.languageCode &&
          author == other.author &&
          version == other.version &&
          description == other.description &&
          fileSize == other.fileSize &&
          downloadUrl == other.downloadUrl &&
          checksum == other.checksum &&
          license == other.license;
}

class DashboardStatsDto {
  final int reviewsToday;
  final int streakDays;
  final int dueCount;

  const DashboardStatsDto({
    required this.reviewsToday,
    required this.streakDays,
    required this.dueCount,
  });

  @override
  int get hashCode =>
      reviewsToday.hashCode ^ streakDays.hashCode ^ dueCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DashboardStatsDto &&
          runtimeType == other.runtimeType &&
          reviewsToday == other.reviewsToday &&
          streakDays == other.streakDays &&
          dueCount == other.dueCount;
}

class DbHealthDto {
  final PlatformInt64 chaptersCount;
  final PlatformInt64 versesCount;
  final PlatformInt64 wordsCount;
  final PlatformInt64 nodesCount;
  final PlatformInt64 edgesCount;
  final PlatformInt64 userMemoryCount;
  final bool isHealthy;
  final List<String> issues;

  const DbHealthDto({
    required this.chaptersCount,
    required this.versesCount,
    required this.wordsCount,
    required this.nodesCount,
    required this.edgesCount,
    required this.userMemoryCount,
    required this.isHealthy,
    required this.issues,
  });

  @override
  int get hashCode =>
      chaptersCount.hashCode ^
      versesCount.hashCode ^
      wordsCount.hashCode ^
      nodesCount.hashCode ^
      edgesCount.hashCode ^
      userMemoryCount.hashCode ^
      isHealthy.hashCode ^
      issues.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DbHealthDto &&
          runtimeType == other.runtimeType &&
          chaptersCount == other.chaptersCount &&
          versesCount == other.versesCount &&
          wordsCount == other.wordsCount &&
          nodesCount == other.nodesCount &&
          edgesCount == other.edgesCount &&
          userMemoryCount == other.userMemoryCount &&
          isHealthy == other.isHealthy &&
          issues == other.issues;
}

class DbQueryResultDto {
  final List<String> columns;
  final List<List<String>> rows;

  const DbQueryResultDto({required this.columns, required this.rows});

  @override
  int get hashCode => columns.hashCode ^ rows.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DbQueryResultDto &&
          runtimeType == other.runtimeType &&
          columns == other.columns &&
          rows == other.rows;
}

class DebugStatsDto {
  final int totalNodesCount;
  final int totalEdgesCount;
  final int dueCount;

  const DebugStatsDto({
    required this.totalNodesCount,
    required this.totalEdgesCount,
    required this.dueCount,
  });

  @override
  int get hashCode =>
      totalNodesCount.hashCode ^ totalEdgesCount.hashCode ^ dueCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DebugStatsDto &&
          runtimeType == other.runtimeType &&
          totalNodesCount == other.totalNodesCount &&
          totalEdgesCount == other.totalEdgesCount &&
          dueCount == other.dueCount;
}

/// Complete metrics for an Echo Recall session
class EchoRecallMetricsDto {
  final List<WordTimingDto> wordTimings;
  final BigInt totalDurationMs;
  final int struggles;

  const EchoRecallMetricsDto({
    required this.wordTimings,
    required this.totalDurationMs,
    required this.struggles,
  });

  @override
  int get hashCode =>
      wordTimings.hashCode ^ totalDurationMs.hashCode ^ struggles.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EchoRecallMetricsDto &&
          runtimeType == other.runtimeType &&
          wordTimings == other.wordTimings &&
          totalDurationMs == other.totalDurationMs &&
          struggles == other.struggles;
}

/// Result from finalizing Echo Recall (energy updates + metrics acknowledgement)
class EchoRecallResultDto {
  final List<EnergyUpdateDto> energyUpdates;
  final int wordsProcessed;
  final double averageEnergy;

  const EchoRecallResultDto({
    required this.energyUpdates,
    required this.wordsProcessed,
    required this.averageEnergy,
  });

  @override
  int get hashCode =>
      energyUpdates.hashCode ^ wordsProcessed.hashCode ^ averageEnergy.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EchoRecallResultDto &&
          runtimeType == other.runtimeType &&
          energyUpdates == other.energyUpdates &&
          wordsProcessed == other.wordsProcessed &&
          averageEnergy == other.averageEnergy;
}

/// Complete state of an Echo Recall session
class EchoRecallStateDto {
  /// All words in the session
  final List<EchoRecallWordDto> words;

  const EchoRecallStateDto({required this.words});

  @override
  int get hashCode => words.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EchoRecallStateDto &&
          runtimeType == other.runtimeType &&
          words == other.words;
}

/// Statistics for an Echo Recall session
class EchoRecallStatsDto {
  final int totalWords;
  final int visibleCount;
  final int obscuredCount;
  final int hiddenCount;
  final double averageEnergy;
  final double masteryPercentage;

  const EchoRecallStatsDto({
    required this.totalWords,
    required this.visibleCount,
    required this.obscuredCount,
    required this.hiddenCount,
    required this.averageEnergy,
    required this.masteryPercentage,
  });

  @override
  int get hashCode =>
      totalWords.hashCode ^
      visibleCount.hashCode ^
      obscuredCount.hashCode ^
      hiddenCount.hashCode ^
      averageEnergy.hashCode ^
      masteryPercentage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EchoRecallStatsDto &&
          runtimeType == other.runtimeType &&
          totalWords == other.totalWords &&
          visibleCount == other.visibleCount &&
          obscuredCount == other.obscuredCount &&
          hiddenCount == other.hiddenCount &&
          averageEnergy == other.averageEnergy &&
          masteryPercentage == other.masteryPercentage;
}

/// A single word in an Echo Recall session
class EchoRecallWordDto {
  /// Node ID (e.g., "WORD:101")
  final String nodeId;

  /// Arabic text
  final String text;

  /// Word visibility state
  final WordVisibilityDto visibility;

  /// Current energy level (0.0 to 1.0)
  final double energy;

  const EchoRecallWordDto({
    required this.nodeId,
    required this.text,
    required this.visibility,
    required this.energy,
  });

  @override
  int get hashCode =>
      nodeId.hashCode ^ text.hashCode ^ visibility.hashCode ^ energy.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EchoRecallWordDto &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          text == other.text &&
          visibility == other.visibility &&
          energy == other.energy;
}

class EnergySnapshotDto {
  final String nodeId;
  final double energy;
  final String? nodeType;
  final String? knowledgeAxis;
  final List<NodeEnergyDto> neighbors;

  const EnergySnapshotDto({
    required this.nodeId,
    required this.energy,
    this.nodeType,
    this.knowledgeAxis,
    required this.neighbors,
  });

  @override
  int get hashCode =>
      nodeId.hashCode ^
      energy.hashCode ^
      nodeType.hashCode ^
      knowledgeAxis.hashCode ^
      neighbors.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EnergySnapshotDto &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          energy == other.energy &&
          nodeType == other.nodeType &&
          knowledgeAxis == other.knowledgeAxis &&
          neighbors == other.neighbors;
}

/// Energy update result from finalizing Echo Recall
class EnergyUpdateDto {
  final String nodeId;
  final double energy;

  const EnergyUpdateDto({required this.nodeId, required this.energy});

  @override
  int get hashCode => nodeId.hashCode ^ energy.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EnergyUpdateDto &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          energy == other.energy;
}

@freezed
sealed class ExerciseDataDto with _$ExerciseDataDto {
  const ExerciseDataDto._();

  const factory ExerciseDataDto.memorization({required String nodeId}) =
      ExerciseDataDto_Memorization;
  const factory ExerciseDataDto.mcqArToEn({
    required String nodeId,
    required List<String> distractorNodeIds,
  }) = ExerciseDataDto_McqArToEn;
  const factory ExerciseDataDto.mcqEnToAr({
    required String nodeId,
    required List<String> distractorNodeIds,
  }) = ExerciseDataDto_McqEnToAr;
  const factory ExerciseDataDto.translation({required String nodeId}) =
      ExerciseDataDto_Translation;
  const factory ExerciseDataDto.contextualTranslation({
    required String nodeId,
    required String verseKey,
  }) = ExerciseDataDto_ContextualTranslation;
  const factory ExerciseDataDto.clozeDeletion({
    required String nodeId,
    required int blankPosition,
  }) = ExerciseDataDto_ClozeDeletion;
  const factory ExerciseDataDto.firstLetterHint({
    required String nodeId,
    required int wordPosition,
  }) = ExerciseDataDto_FirstLetterHint;
  const factory ExerciseDataDto.missingWordMcq({
    required String nodeId,
    required int blankPosition,
    required List<String> distractorNodeIds,
  }) = ExerciseDataDto_MissingWordMcq;
  const factory ExerciseDataDto.nextWordMcq({
    required String nodeId,
    required int contextPosition,
    required List<String> distractorNodeIds,
  }) = ExerciseDataDto_NextWordMcq;
  const factory ExerciseDataDto.fullVerseInput({required String nodeId}) =
      ExerciseDataDto_FullVerseInput;
  const factory ExerciseDataDto.ayahChain({
    required String nodeId,
    required List<String> verseKeys,
    required BigInt currentIndex,
    required BigInt completedCount,
  }) = ExerciseDataDto_AyahChain;
  const factory ExerciseDataDto.findMistake({
    required String nodeId,
    required int mistakePosition,
    required String correctWordNodeId,
    required String incorrectWordNodeId,
  }) = ExerciseDataDto_FindMistake;
  const factory ExerciseDataDto.ayahSequence({
    required String nodeId,
    required List<String> correctSequence,
  }) = ExerciseDataDto_AyahSequence;
  const factory ExerciseDataDto.sequenceRecall({
    required String nodeId,
    required List<String> correctSequence,
    required List<List<String>> options,
  }) = ExerciseDataDto_SequenceRecall;
  const factory ExerciseDataDto.firstWordRecall({
    required String nodeId,
    required String verseKey,
  }) = ExerciseDataDto_FirstWordRecall;
  const factory ExerciseDataDto.identifyRoot({
    required String nodeId,
    required String root,
  }) = ExerciseDataDto_IdentifyRoot;
  const factory ExerciseDataDto.reverseCloze({
    required String nodeId,
    required int blankPosition,
  }) = ExerciseDataDto_ReverseCloze;
  const factory ExerciseDataDto.translatePhrase({
    required String nodeId,
    required int translatorId,
  }) = ExerciseDataDto_TranslatePhrase;
  const factory ExerciseDataDto.posTagging({
    required String nodeId,
    required String correctPos,
    required List<String> options,
  }) = ExerciseDataDto_PosTagging;
  const factory ExerciseDataDto.crossVerseConnection({
    required String nodeId,
    required List<String> relatedVerseIds,
    required String connectionTheme,
  }) = ExerciseDataDto_CrossVerseConnection;

  /// Echo Recall exercise - progressive blur memorization
  const factory ExerciseDataDto.echoRecall({
    /// User ID for session tracking
    required String userId,

    /// List of ayah node IDs to practice (e.g., ["VERSE:1:1", "VERSE:1:2"])
    required List<String> ayahNodeIds,
  }) = ExerciseDataDto_EchoRecall;
}

/// Hint shown for obscured words
class HintDto {
  /// "first", "last", or "both"
  final String hintType;

  /// First character hint (if applicable)
  final String? firstChar;

  /// Last character hint (if applicable)
  final String? lastChar;

  const HintDto({required this.hintType, this.firstChar, this.lastChar});

  @override
  int get hashCode =>
      hintType.hashCode ^ firstChar.hashCode ^ lastChar.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is HintDto &&
          runtimeType == other.runtimeType &&
          hintType == other.hintType &&
          firstChar == other.firstChar &&
          lastChar == other.lastChar;
}

class InstalledPackageDto {
  final String packageId;
  final PlatformInt64 installedAt;
  final bool enabled;

  const InstalledPackageDto({
    required this.packageId,
    required this.installedAt,
    required this.enabled,
  });

  @override
  int get hashCode =>
      packageId.hashCode ^ installedAt.hashCode ^ enabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is InstalledPackageDto &&
          runtimeType == other.runtimeType &&
          packageId == other.packageId &&
          installedAt == other.installedAt &&
          enabled == other.enabled;
}

class LanguageDto {
  final String code;
  final String englishName;
  final String nativeName;
  final String direction;

  const LanguageDto({
    required this.code,
    required this.englishName,
    required this.nativeName,
    required this.direction,
  });

  @override
  int get hashCode =>
      code.hashCode ^
      englishName.hashCode ^
      nativeName.hashCode ^
      direction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LanguageDto &&
          runtimeType == other.runtimeType &&
          code == other.code &&
          englishName == other.englishName &&
          nativeName == other.nativeName &&
          direction == other.direction;
}

class NodeData {
  final String id;
  final String nodeType;
  final Map<String, String> metadata;

  const NodeData({
    required this.id,
    required this.nodeType,
    required this.metadata,
  });

  @override
  int get hashCode => id.hashCode ^ nodeType.hashCode ^ metadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeData &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          nodeType == other.nodeType &&
          metadata == other.metadata;
}

class NodeEnergyDto {
  final String nodeId;
  final double energy;
  final double edgeWeight;

  const NodeEnergyDto({
    required this.nodeId,
    required this.energy,
    required this.edgeWeight,
  });

  @override
  int get hashCode => nodeId.hashCode ^ energy.hashCode ^ edgeWeight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeEnergyDto &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          energy == other.energy &&
          edgeWeight == other.edgeWeight;
}

class NodeFilterDto {
  final String? nodeType;
  final double? minEnergy;
  final double? maxEnergy;
  final String? range;

  const NodeFilterDto({
    this.nodeType,
    this.minEnergy,
    this.maxEnergy,
    this.range,
  });

  @override
  int get hashCode =>
      nodeType.hashCode ^
      minEnergy.hashCode ^
      maxEnergy.hashCode ^
      range.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeFilterDto &&
          runtimeType == other.runtimeType &&
          nodeType == other.nodeType &&
          minEnergy == other.minEnergy &&
          maxEnergy == other.maxEnergy &&
          range == other.range;
}

class NodeSearchDto {
  final String nodeId;
  final String nodeType;
  final String? knowledgeAxis;
  final String preview;

  const NodeSearchDto({
    required this.nodeId,
    required this.nodeType,
    this.knowledgeAxis,
    required this.preview,
  });

  @override
  int get hashCode =>
      nodeId.hashCode ^
      nodeType.hashCode ^
      knowledgeAxis.hashCode ^
      preview.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeSearchDto &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          nodeType == other.nodeType &&
          knowledgeAxis == other.knowledgeAxis &&
          preview == other.preview;
}

class PropagationDiagnosticsDto {
  final bool nodeFound;
  final String? nodeType;
  final int totalEdges;
  final String message;

  const PropagationDiagnosticsDto({
    required this.nodeFound,
    this.nodeType,
    required this.totalEdges,
    required this.message,
  });

  @override
  int get hashCode =>
      nodeFound.hashCode ^
      nodeType.hashCode ^
      totalEdges.hashCode ^
      message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PropagationDiagnosticsDto &&
          runtimeType == other.runtimeType &&
          nodeFound == other.nodeFound &&
          nodeType == other.nodeType &&
          totalEdges == other.totalEdges &&
          message == other.message;
}

class PropagationResultDto {
  final List<NodeEnergyDto> before;
  final List<NodeEnergyDto> after;
  final PropagationDiagnosticsDto diagnostics;

  const PropagationResultDto({
    required this.before,
    required this.after,
    required this.diagnostics,
  });

  @override
  int get hashCode => before.hashCode ^ after.hashCode ^ diagnostics.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PropagationResultDto &&
          runtimeType == other.runtimeType &&
          before == other.before &&
          after == other.after &&
          diagnostics == other.diagnostics;
}

class SessionDto {
  final String id;
  final String userId;
  final String goalId;
  final PlatformInt64 startedAt;
  final PlatformInt64? completedAt;
  final int itemsCount;
  final int itemsCompleted;

  const SessionDto({
    required this.id,
    required this.userId,
    required this.goalId,
    required this.startedAt,
    this.completedAt,
    required this.itemsCount,
    required this.itemsCompleted,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      userId.hashCode ^
      goalId.hashCode ^
      startedAt.hashCode ^
      completedAt.hashCode ^
      itemsCount.hashCode ^
      itemsCompleted.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionDto &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          userId == other.userId &&
          goalId == other.goalId &&
          startedAt == other.startedAt &&
          completedAt == other.completedAt &&
          itemsCount == other.itemsCount &&
          itemsCompleted == other.itemsCompleted;
}

class SessionItemDto {
  final String sessionId;
  final int position;
  final String nodeId;
  final String exerciseType;
  final ExerciseDataDto exercise;

  const SessionItemDto({
    required this.sessionId,
    required this.position,
    required this.nodeId,
    required this.exerciseType,
    required this.exercise,
  });

  @override
  int get hashCode =>
      sessionId.hashCode ^
      position.hashCode ^
      nodeId.hashCode ^
      exerciseType.hashCode ^
      exercise.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionItemDto &&
          runtimeType == other.runtimeType &&
          sessionId == other.sessionId &&
          position == other.position &&
          nodeId == other.nodeId &&
          exerciseType == other.exerciseType &&
          exercise == other.exercise;
}

class SessionPreviewDto {
  final String nodeId;
  final String nodeType;
  final String previewText;
  final double energy;
  final double priorityScore;

  const SessionPreviewDto({
    required this.nodeId,
    required this.nodeType,
    required this.previewText,
    required this.energy,
    required this.priorityScore,
  });

  @override
  int get hashCode =>
      nodeId.hashCode ^
      nodeType.hashCode ^
      previewText.hashCode ^
      energy.hashCode ^
      priorityScore.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionPreviewDto &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          nodeType == other.nodeType &&
          previewText == other.previewText &&
          energy == other.energy &&
          priorityScore == other.priorityScore;
}

class SessionSummaryDto {
  final String sessionId;
  final int itemsCount;
  final int itemsCompleted;
  final PlatformInt64 durationMs;
  final int againCount;
  final int hardCount;
  final int goodCount;
  final int easyCount;

  const SessionSummaryDto({
    required this.sessionId,
    required this.itemsCount,
    required this.itemsCompleted,
    required this.durationMs,
    required this.againCount,
    required this.hardCount,
    required this.goodCount,
    required this.easyCount,
  });

  @override
  int get hashCode =>
      sessionId.hashCode ^
      itemsCount.hashCode ^
      itemsCompleted.hashCode ^
      durationMs.hashCode ^
      againCount.hashCode ^
      hardCount.hashCode ^
      goodCount.hashCode ^
      easyCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionSummaryDto &&
          runtimeType == other.runtimeType &&
          sessionId == other.sessionId &&
          itemsCount == other.itemsCount &&
          itemsCompleted == other.itemsCompleted &&
          durationMs == other.durationMs &&
          againCount == other.againCount &&
          hardCount == other.hardCount &&
          goodCount == other.goodCount &&
          easyCount == other.easyCount;
}

class SurahInfo {
  final int number;
  final String name;

  const SurahInfo({required this.number, required this.name});

  @override
  int get hashCode => number.hashCode ^ name.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SurahInfo &&
          runtimeType == other.runtimeType &&
          number == other.number &&
          name == other.name;
}

class TranslatorDto {
  final int id;
  final String slug;
  final String fullName;
  final String languageCode;
  final String? description;
  final String? license;

  const TranslatorDto({
    required this.id,
    required this.slug,
    required this.fullName,
    required this.languageCode,
    this.description,
    this.license,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      slug.hashCode ^
      fullName.hashCode ^
      languageCode.hashCode ^
      description.hashCode ^
      license.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TranslatorDto &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          slug == other.slug &&
          fullName == other.fullName &&
          languageCode == other.languageCode &&
          description == other.description &&
          license == other.license;
}

class VerseDto {
  final String key;
  final String textUthmani;
  final int chapterNumber;
  final int verseNumber;

  const VerseDto({
    required this.key,
    required this.textUthmani,
    required this.chapterNumber,
    required this.verseNumber,
  });

  @override
  int get hashCode =>
      key.hashCode ^
      textUthmani.hashCode ^
      chapterNumber.hashCode ^
      verseNumber.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VerseDto &&
          runtimeType == other.runtimeType &&
          key == other.key &&
          textUthmani == other.textUthmani &&
          chapterNumber == other.chapterNumber &&
          verseNumber == other.verseNumber;
}

class WordDto {
  final int id;
  final String textUthmani;
  final String verseKey;
  final int position;

  const WordDto({
    required this.id,
    required this.textUthmani,
    required this.verseKey,
    required this.position,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      textUthmani.hashCode ^
      verseKey.hashCode ^
      position.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WordDto &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          textUthmani == other.textUthmani &&
          verseKey == other.verseKey &&
          position == other.position;
}

/// Per-word timing for metrics
class WordTimingDto {
  final String wordNodeId;
  final BigInt durationMs;

  const WordTimingDto({required this.wordNodeId, required this.durationMs});

  @override
  int get hashCode => wordNodeId.hashCode ^ durationMs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WordTimingDto &&
          runtimeType == other.runtimeType &&
          wordNodeId == other.wordNodeId &&
          durationMs == other.durationMs;
}

/// Visibility state for a word in Echo Recall
class WordVisibilityDto {
  /// "visible", "obscured", or "hidden"
  final String visibilityType;

  /// Hint shown when obscured
  final HintDto? hint;

  /// Blur coverage (0.0 to 1.0) when obscured
  final double? coverage;

  const WordVisibilityDto({
    required this.visibilityType,
    this.hint,
    this.coverage,
  });

  @override
  int get hashCode =>
      visibilityType.hashCode ^ hint.hashCode ^ coverage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WordVisibilityDto &&
          runtimeType == other.runtimeType &&
          visibilityType == other.visibilityType &&
          hint == other.hint &&
          coverage == other.coverage;
}

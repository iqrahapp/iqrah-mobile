<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compare Your Recitation - Iqrah Audio</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&family=Roboto:wght@300;400;600&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .nav-links {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #eee;
        }

        .nav-links a {
            display: inline-block;
            padding: 10px 25px;
            margin: 0 10px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 500;
            transition: all 0.3s;
        }

        .nav-links a:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .nav-links a.active {
            background: #764ba2;
        }

        .upload-section {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 40px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
        }

        .upload-section h2 {
            color: #667eea;
            margin-bottom: 20px;
        }

        .ayah-selector {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .ayah-selector select, .ayah-selector input {
            padding: 12px 20px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1.1em;
            min-width: 150px;
        }

        .upload-methods {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }

        .upload-card {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .upload-card h3 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .upload-card button, .file-input-wrapper {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 15px;
        }

        .upload-card button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .upload-card button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            overflow: hidden;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .recording-indicator {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 8px;
            border-left: 5px solid #ffc107;
        }

        .recording-indicator.active {
            display: block;
        }

        .pulse {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #dc3545;
            border-radius: 50%;
            margin-right: 10px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .file-info {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #d4edda;
            border-radius: 8px;
            border-left: 5px solid #28a745;
        }

        .file-info.active {
            display: block;
        }

        .compare-btn {
            width: 100%;
            max-width: 500px;
            margin: 30px auto;
            display: block;
            padding: 20px;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.3em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .compare-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(40, 167, 69, 0.4);
        }

        .compare-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #6c757d;
        }

        .loading {
            text-align: center;
            padding: 40px;
            display: none;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .results {
            display: none;
        }

        .results.active {
            display: block;
        }

        .score-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 30px;
        }

        .score-card h2 {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .score-card p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .component-scores {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .component-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            border-left: 5px solid #667eea;
        }

        .component-card h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .component-card .score {
            font-size: 2em;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        .component-card .notes {
            color: #666;
            font-size: 0.9em;
            line-height: 1.6;
        }

        /* Interactive Visualization Section */
        .interactive-viz {
            margin-top: 40px;
            margin-bottom: 40px;
        }

        .audio-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .audio-player-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            border-left: 5px solid #667eea;
        }

        .audio-player-card.student {
            border-left-color: #4169e1;
        }

        .audio-player-card.reference {
            border-left-color: #dc3545;
        }

        .audio-player-card h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .audio-player-card audio {
            width: 100%;
            height: 50px;
        }

        .pitch-extractor-selector {
            margin-bottom: 20px;
            text-align: center;
        }

        .pitch-extractor-selector label {
            margin-right: 10px;
            font-weight: 600;
            color: #333;
        }

        .pitch-extractor-selector select {
            padding: 8px 15px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1em;
        }

        /* Arabic Words Display (RTL) */
        .arabic-words {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            font-family: 'Amiri', serif;
            font-size: 2em;
            line-height: 2;
            direction: rtl;
        }

        .arabic-word {
            display: inline-block;
            margin: 0 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .arabic-word:hover {
            transform: scale(1.1);
        }

        .tajweed-segment {
            display: inline;
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Pitch Plot */
        #pitchPlot {
            width: 100%;
            min-height: 600px;
            border: 2px solid #eee;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        /* Overlay cursors for both audio players */
        #studentCursorOverlay, #referenceCursorOverlay {
            position: absolute;
            width: 3px;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
            transform: translateX(-50%);
            transition: none;
            will-change: left;
        }

        #studentCursorOverlay {
            background: linear-gradient(to bottom, transparent 0%, #4169e1 20%, #4169e1 80%, transparent 100%);
        }

        #referenceCursorOverlay {
            background: linear-gradient(to bottom, transparent 0%, #dc3545 20%, #dc3545 80%, transparent 100%);
        }

        #studentCursorDot, #referenceCursorDot {
            position: absolute;
            width: 16px;
            height: 16px;
            border: 3px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1001;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: none;
            will-change: left, top;
        }

        #studentCursorDot {
            background: #4169e1;
        }

        #referenceCursorDot {
            background: #dc3545;
        }

        /* Static Visualizations Section */
        .static-visualizations {
            margin-top: 40px;
        }

        .viz-section {
            margin-bottom: 40px;
        }

        .viz-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .viz-section img {
            width: 100%;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .viz-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 40px;
        }

        .feedback {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px;
            border-radius: 8px;
            margin-top: 30px;
        }

        .feedback h3 {
            color: #856404;
            margin-bottom: 15px;
        }

        .feedback ul {
            list-style: none;
            padding: 0;
        }

        .feedback li {
            padding: 8px 0;
            color: #856404;
        }

        .feedback li:before {
            content: "‚Ä¢ ";
            font-weight: bold;
        }

        .reference-info {
            background: #e7f3ff;
            border-left: 5px solid #0066cc;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .reference-info h3 {
            color: #0066cc;
            margin-bottom: 10px;
        }

        .reference-info p {
            color: #555;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéôÔ∏è Compare Your Recitation</h1>
        <p class="subtitle">Record or upload your recitation and compare against Sheikh Husary's golden reference</p>

        <div class="nav-links">
            <a href="/">üìä Analysis</a>
            <a href="/compare" class="active">üéØ Compare</a>
        </div>

        <div class="reference-info">
            <h3>üìö Golden Reference</h3>
            <p>Your recitation will be compared against <strong>Sheikh Mahmoud Khalil Al-Husary's</strong> masterful recitation,
            which includes:</p>
            <ul style="margin-top: 10px; margin-left: 20px;">
                <li>‚úì Perfect phoneme alignment with Wav2Vec2 CTC</li>
                <li>‚úì Precise pitch tracking with SwiftF0</li>
                <li>‚úì Comprehensive Tajweed rule annotations</li>
                <li>‚úì Statistical analysis (tempo, pitch, duration)</li>
            </ul>
        </div>

        <div class="upload-section">
            <h2>1Ô∏è‚É£ Select Ayah</h2>
            <div class="ayah-selector">
                <div>
                    <label>Surah (1-114)</label>
                    <select id="surahSelect">
                        <!-- Populated dynamically -->
                    </select>
                </div>
                <div>
                    <label>Ayah</label>
                    <input type="number" id="ayahInput" min="1" value="1">
                </div>
            </div>

            <h2>2Ô∏è‚É£ Provide Your Recitation</h2>
            <div class="upload-methods">
                <div class="upload-card">
                    <h3>üé§ Record Live</h3>
                    <p style="color: #666; margin-bottom: 15px;">Record your recitation directly in the browser</p>
                    <button id="recordBtn" onclick="toggleRecording()">Start Recording</button>
                    <div class="recording-indicator" id="recordingIndicator">
                        <span class="pulse"></span>
                        <span>Recording... <span id="recordTime">0:00</span></span>
                    </div>
                    <div class="file-info" id="recordInfo">
                        ‚úÖ Recording ready! Duration: <span id="recordDuration">-</span>
                    </div>
                </div>

                <div class="upload-card">
                    <h3>üìÅ Upload Audio File</h3>
                    <p style="color: #666; margin-bottom: 15px;">Upload a pre-recorded MP3, WAV, or OGG file</p>
                    <label class="file-input-wrapper">
                        <input type="file" id="audioFile" accept="audio/*" onchange="handleFileSelect(event)">
                        üìÇ Choose File
                    </label>
                    <div class="file-info" id="fileInfo">
                        ‚úÖ File selected: <span id="fileName">-</span>
                    </div>
                </div>
            </div>
        </div>

        <button class="compare-btn" id="compareBtn" onclick="compareWithReference()" disabled>
            üîç Compare Against Husary Reference
        </button>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Analyzing your recitation and generating comparisons...</p>
            <p style="font-size: 0.9em; color: #666; margin-top: 10px;">This may take 30-60 seconds</p>
        </div>

        <div class="results" id="results">
            <div class="score-card">
                <h2 id="overallScore">-</h2>
                <p>Overall Score vs Husary Reference</p>
                <p style="font-size: 0.9em; margin-top: 10px;">Confidence: <span id="confidence">-</span></p>
            </div>

            <div class="component-scores">
                <div class="component-card">
                    <h3>üéµ Rhythm</h3>
                    <div class="score" id="rhythmScore">-</div>
                    <div class="notes" id="rhythmNotes">-</div>
                </div>

                <div class="component-card">
                    <h3>üéº Melody</h3>
                    <div class="score" id="melodyScore">-</div>
                    <div class="notes" id="melodyNotes">-</div>
                </div>

                <div class="component-card">
                    <h3>‚è±Ô∏è Duration (Madd)</h3>
                    <div class="score" id="durationScore">-</div>
                    <div class="notes" id="durationNotes">-</div>
                </div>
            </div>

            <!-- INTERACTIVE VISUALIZATION SECTION -->
            <div class="interactive-viz">
                <h2 style="text-align: center; color: #667eea; margin-bottom: 30px;">üéØ Interactive Comparison</h2>

                <!-- Audio Players with Dual Control -->
                <div class="audio-controls">
                    <div class="audio-player-card student">
                        <h3>üîµ Your Recitation</h3>
                        <audio id="studentAudioPlayer" controls></audio>
                    </div>
                    <div class="audio-player-card reference">
                        <h3>üî¥ Husary Reference</h3>
                        <audio id="referenceAudioPlayer" controls></audio>
                    </div>
                </div>

                <!-- Visualization Controls -->
                <div style="display: flex; justify-content: center; gap: 30px; margin-bottom: 20px;">
                    <div class="pitch-extractor-selector">
                        <label for="pitchExtractorSelect">Pitch Algorithm:</label>
                        <select id="pitchExtractorSelect" onchange="updatePitchExtractor()">
                            <option value="swiftf0">SwiftF0 (Fast)</option>
                            <option value="crepe-fast">CREPE-Tiny (Good)</option>
                            <option value="crepe-accurate">CREPE-Full (Best)</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 20px; align-items: center;">
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" id="showStudentPhonemes" checked onchange="togglePhonemes()">
                            <span style="color: #4169e1; font-weight: 600;">üîµ Student Phonemes</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" id="showReferencePhonemes" checked onchange="togglePhonemes()">
                            <span style="color: #dc3545; font-weight: 600;">üî¥ Reference Phonemes</span>
                        </label>
                    </div>
                </div>

                <!-- Arabic Words (RTL) -->
                <div class="arabic-words" id="arabicWordsStudent"></div>

                <!-- Interactive Plotly Chart with Dual Cursors -->
                <div style="position: relative;">
                    <div id="pitchPlot"></div>
                    <div id="studentCursorOverlay" style="display: none;"></div>
                    <div id="studentCursorDot" style="display: none;"></div>
                    <div id="referenceCursorOverlay" style="display: none;"></div>
                    <div id="referenceCursorDot" style="display: none;"></div>
                </div>
            </div>

            <!-- STATIC VISUALIZATIONS -->
            <div class="static-visualizations">
                <h2 style="text-align: center; color: #667eea; margin-bottom: 30px;">üìä Static Analysis Charts</h2>

                <div class="viz-section">
                    <h3>üéØ DTW Alignment Path</h3>
                    <p style="color: #666; margin-bottom: 15px;">Shows how your timing maps to Husary's timing</p>
                    <img id="vizDtwPath" alt="DTW Path">
                </div>

                <div class="viz-section">
                    <h3>üéµ Pitch Comparison</h3>
                    <p style="color: #666; margin-bottom: 15px;">Your pitch vs Husary's pitch (top) and melodic contour (bottom)</p>
                    <img id="vizPitchComparison" alt="Pitch Comparison">
                </div>

                <div class="viz-section">
                    <h3>ü•Å Rhythm Comparison</h3>
                    <p style="color: #666; margin-bottom: 15px;">Your rhythm patterns compared to Husary's</p>
                    <img id="vizRhythmComparison" alt="Rhythm Comparison">
                </div>

                <div class="viz-grid">
                    <div class="viz-section">
                        <h3>üé§ Your Spectrogram</h3>
                        <img id="vizStudentSpectrogram" alt="Your Spectrogram">
                    </div>
                    <div class="viz-section">
                        <h3>üìö Husary Reference</h3>
                        <img id="vizReferenceSpectrogram" alt="Husary Spectrogram">
                    </div>
                </div>
            </div>

            <div class="feedback">
                <h3>üí° Feedback & Improvement Suggestions</h3>
                <ul id="feedbackList"></ul>
            </div>
        </div>
    </div>

    <script>
        let mediaRecorder;
        let audioChunks = [];
        let recordingStartTime;
        let recordingInterval;
        let userAudioBlob = null;
        let comparisonData = null;
        let studentAnimationFrame = null;
        let referenceAnimationFrame = null;
        let plotBounds = null;

        // Surah names
        const SURAH_NAMES = [
            "Al-Fatihah", "Al-Baqarah", "Ali 'Imran", "An-Nisa", "Al-Ma'idah", "Al-An'am",
            "Al-A'raf", "Al-Anfal", "At-Tawbah", "Yunus", "Hud", "Yusuf", "Ar-Ra'd",
            "Ibrahim", "Al-Hijr", "An-Nahl", "Al-Isra", "Al-Kahf", "Maryam", "Taha",
            "Al-Anbya", "Al-Hajj", "Al-Mu'minun", "An-Nur", "Al-Furqan", "Ash-Shu'ara",
            "An-Naml", "Al-Qasas", "Al-'Ankabut", "Ar-Rum", "Luqman", "As-Sajdah",
            "Al-Ahzab", "Saba", "Fatir", "Ya-Sin", "As-Saffat", "Sad", "Az-Zumar",
            "Ghafir", "Fussilat", "Ash-Shuraa", "Az-Zukhruf", "Ad-Dukhan", "Al-Jathiyah",
            "Al-Ahqaf", "Muhammad", "Al-Fath", "Al-Hujurat", "Qaf", "Adh-Dhariyat",
            "At-Tur", "An-Najm", "Al-Qamar", "Ar-Rahman", "Al-Waqi'ah", "Al-Hadid",
            "Al-Mujadila", "Al-Hashr", "Al-Mumtahanah", "As-Saf", "Al-Jumu'ah",
            "Al-Munafiqun", "At-Taghabun", "At-Talaq", "At-Tahrim", "Al-Mulk",
            "Al-Qalam", "Al-Haqqah", "Al-Ma'arij", "Nuh", "Al-Jinn", "Al-Muzzammil",
            "Al-Muddaththir", "Al-Qiyamah", "Al-Insan", "Al-Mursalat", "An-Naba",
            "An-Nazi'at", "Abasa", "At-Takwir", "Al-Infitar", "Al-Mutaffifin",
            "Al-Inshiqaq", "Al-Buruj", "At-Tariq", "Al-A'la", "Al-Ghashiyah", "Al-Fajr",
            "Al-Balad", "Ash-Shams", "Al-Layl", "Ad-Duhaa", "Ash-Sharh", "At-Tin",
            "Al-'Alaq", "Al-Qadr", "Al-Bayyinah", "Az-Zalzalah", "Al-'Adiyat",
            "Al-Qari'ah", "At-Takathur", "Al-'Asr", "Al-Humazah", "Al-Fil", "Quraysh",
            "Al-Ma'un", "Al-Kawthar", "Al-Kafirun", "An-Nasr", "Al-Masad", "Al-Ikhlas",
            "Al-Falaq", "An-Nas"
        ];

        // Populate surah dropdown
        function populateSurahDropdown() {
            const select = document.getElementById('surahSelect');
            select.innerHTML = '';
            for (let i = 1; i <= 114; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${i} - ${SURAH_NAMES[i-1]}`;
                select.appendChild(option);
            }
        }

        async function toggleRecording() {
            const btn = document.getElementById('recordBtn');
            const indicator = document.getElementById('recordingIndicator');
            const info = document.getElementById('recordInfo');

            if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                // Start recording
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];

                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = () => {
                        userAudioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        const duration = ((Date.now() - recordingStartTime) / 1000).toFixed(1);
                        document.getElementById('recordDuration').textContent = duration + 's';
                        info.classList.add('active');
                        document.getElementById('compareBtn').disabled = false;

                        // Hide file info if file was selected
                        document.getElementById('fileInfo').classList.remove('active');
                    };

                    mediaRecorder.start();
                    recordingStartTime = Date.now();

                    btn.textContent = 'Stop Recording';
                    btn.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                    indicator.classList.add('active');
                    info.classList.remove('active');

                    // Update timer
                    recordingInterval = setInterval(() => {
                        const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                        const mins = Math.floor(elapsed / 60);
                        const secs = elapsed % 60;
                        document.getElementById('recordTime').textContent =
                            `${mins}:${secs.toString().padStart(2, '0')}`;
                    }, 1000);

                } catch (err) {
                    alert('Error accessing microphone: ' + err.message);
                }
            } else {
                // Stop recording
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                clearInterval(recordingInterval);

                btn.textContent = 'Start Recording';
                btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                indicator.classList.remove('active');
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                userAudioBlob = file;
                document.getElementById('fileName').textContent = file.name;
                document.getElementById('fileInfo').classList.add('active');
                document.getElementById('compareBtn').disabled = false;

                // Hide recording info if recording was done
                document.getElementById('recordInfo').classList.remove('active');
            }
        }

        async function compareWithReference() {
            if (!userAudioBlob) {
                alert('Please record or upload your recitation first');
                return;
            }

            const surah = document.getElementById('surahSelect').value;
            const ayah = document.getElementById('ayahInput').value;

            // Show loading
            document.getElementById('loading').classList.add('active');
            document.getElementById('results').classList.remove('active');
            document.getElementById('compareBtn').disabled = true;

            try {
                // Upload audio file
                const formData = new FormData();
                formData.append('audio', userAudioBlob, 'user_recitation.webm');
                formData.append('surah', surah);
                formData.append('ayah', ayah);
                formData.append('pitch_extractor', document.getElementById('pitchExtractorSelect').value);

                const response = await fetch('/api/compare/user', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                console.log('API Response:', data);

                if (data.success) {
                    comparisonData = data;
                    displayResults(data);
                } else {
                    console.error('API Error:', data);
                    alert('Error: ' + (data.error || data.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to compare recitation: ' + error.message);
            } finally {
                document.getElementById('loading').classList.remove('active');
                document.getElementById('compareBtn').disabled = false;
            }
        }

        function displayResults(data) {
            const comparison = data.comparison;
            const visualizations = data.visualizations;

            // DEBUG: Check pitch data
            console.log('Student pitch data:', {
                length: data.student_pitch.time.length,
                duration: data.student_pitch.time[data.student_pitch.time.length - 1],
                zero_frames: data.student_pitch.f0_hz.filter(f => f === 0).length
            });
            console.log('Reference pitch data:', {
                length: data.reference_pitch.time.length,
                duration: data.reference_pitch.time[data.reference_pitch.time.length - 1],
                zero_frames: data.reference_pitch.f0_hz.filter(f => f === 0).length
            });

            // Overall score
            document.getElementById('overallScore').textContent = comparison.overall.toFixed(1) + '/100';
            document.getElementById('confidence').textContent = (comparison.confidence * 100).toFixed(0) + '%';

            // Component scores
            document.getElementById('rhythmScore').textContent = comparison.rhythm.score.toFixed(1) + '/100';
            document.getElementById('rhythmNotes').textContent = comparison.rhythm.notes.join('. ');

            document.getElementById('melodyScore').textContent = comparison.melody.score.toFixed(1) + '/100';
            document.getElementById('melodyNotes').textContent = comparison.melody.notes.join('. ');

            document.getElementById('durationScore').textContent = comparison.durations.overall.toFixed(1) + '/100';
            document.getElementById('durationNotes').textContent = comparison.durations.notes.join('. ');

            // Static visualizations
            document.getElementById('vizDtwPath').src = visualizations.dtw_path;
            document.getElementById('vizPitchComparison').src = visualizations.pitch_comparison;
            document.getElementById('vizRhythmComparison').src = visualizations.rhythm_comparison;
            document.getElementById('vizStudentSpectrogram').src = visualizations.student_spectrogram;
            document.getElementById('vizReferenceSpectrogram').src = visualizations.reference_spectrogram;

            // Feedback
            const feedbackList = document.getElementById('feedbackList');
            feedbackList.innerHTML = '';
            comparison.feedback.all_notes.forEach(note => {
                const li = document.createElement('li');
                if (typeof note === 'object' && note.text) {
                    const category = note.category || '';
                    li.innerHTML = `<strong>[${category}]</strong> ${note.text}`;
                } else {
                    li.textContent = note;
                }
                feedbackList.appendChild(li);
            });

            // Set audio players
            const studentUrl = data.student_audio_url || URL.createObjectURL(userAudioBlob);
            const referenceUrl = data.reference_audio_url;

            const studentPlayer = document.getElementById('studentAudioPlayer');
            const referencePlayer = document.getElementById('referenceAudioPlayer');

            studentPlayer.src = studentUrl;
            referencePlayer.src = referenceUrl;

            // DEBUG: Log actual audio durations when loaded
            studentPlayer.addEventListener('loadedmetadata', () => {
                console.log('Student audio duration (browser):', studentPlayer.duration);
                console.log('Student pitch duration (extracted):', data.student_pitch.time[data.student_pitch.time.length - 1]);
                console.log('Duration mismatch:', Math.abs(studentPlayer.duration - data.student_pitch.time[data.student_pitch.time.length - 1]));
            }, { once: true });

            referencePlayer.addEventListener('loadedmetadata', () => {
                console.log('Reference audio duration (browser):', referencePlayer.duration);
                console.log('Reference pitch duration (extracted):', data.reference_pitch.time[data.reference_pitch.time.length - 1]);
            }, { once: true });

            // Display Arabic words
            displayArabicWords(data.student_arabic_words, data.student_word_segments);

            // Plot interactive visualization
            plotInteractiveComparison(data);

            // Setup dual cursor tracking
            setupDualCursorTracking();

            // Show results
            document.getElementById('results').classList.add('active');
            document.getElementById('results').scrollIntoView({ behavior: 'smooth' });
        }

        function displayArabicWords(words, wordSegments) {
            const arabicWords = document.getElementById('arabicWordsStudent');
            arabicWords.innerHTML = '';

            if (!words || !wordSegments) return;

            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                const wordSpan = document.createElement('span');
                wordSpan.className = 'arabic-word';

                for (const seg of word.segments) {
                    const segSpan = document.createElement('span');
                    segSpan.className = 'tajweed-segment';
                    segSpan.textContent = seg.text;
                    if (seg.tajweed_class) {
                        segSpan.style.backgroundColor = seg.color;
                        segSpan.title = seg.tajweed_class;
                    }
                    wordSpan.appendChild(segSpan);
                }

                // Add click handler to seek to word
                const wordSegment = wordSegments[i];
                if (wordSegment) {
                    wordSpan.dataset.startMs = wordSegment.start_ms;
                    wordSpan.style.cursor = 'pointer';
                    wordSpan.addEventListener('click', () => {
                        const wordStartS = parseFloat(wordSpan.dataset.startMs) / 1000;
                        document.getElementById('studentAudioPlayer').currentTime = wordStartS;
                        const player = document.getElementById('studentAudioPlayer');
                        if (player.paused) {
                            player.play();
                        }
                    });
                }

                arabicWords.appendChild(wordSpan);
            }
        }

        function plotInteractiveComparison(data) {
            // Combine student and reference pitch data
            const studentPitch = data.student_pitch;
            const referencePitch = data.reference_pitch;

            // Get DTW alignment path from rhythm comparison
            const dtwPath = data.comparison.rhythm.path;  // [[student_idx, ref_idx], ...]

            console.log('DTW path length:', dtwPath ? dtwPath.length : 0);

            // Build time warping function: student_time -> reference_time
            function warpStudentTime(studentTime) {
                if (!dtwPath || dtwPath.length === 0) {
                    // Fallback to linear scaling
                    const studentDuration = studentPitch.time[studentPitch.time.length - 1];
                    const refDuration = referencePitch.time[referencePitch.time.length - 1];
                    return (studentTime / studentDuration) * refDuration;
                }

                // Find student time in pitch array
                let studentIdx = 0;
                for (let i = 0; i < studentPitch.time.length; i++) {
                    if (studentPitch.time[i] >= studentTime) {
                        studentIdx = i;
                        break;
                    }
                }

                // Find corresponding reference index in DTW path
                // DTW path maps feature indices (downsampled), need to scale
                const studentFeatureIdx = Math.floor(studentIdx / (studentPitch.time.length / dtwPath[dtwPath.length-1][0]));

                for (let i = 0; i < dtwPath.length; i++) {
                    if (dtwPath[i][0] >= studentFeatureIdx) {
                        const refFeatureIdx = dtwPath[i][1];
                        // Map back to reference time
                        const refIdx = Math.floor(refFeatureIdx * (referencePitch.time.length / dtwPath[dtwPath.length-1][1]));
                        return referencePitch.time[Math.min(refIdx, referencePitch.time.length - 1)];
                    }
                }

                return referencePitch.time[referencePitch.time.length - 1];
            }

            // Warp student time to reference time for plotting
            const studentTimeWarped = studentPitch.time.map(t => warpStudentTime(t));

            // Save warping function globally for cursor tracking
            window.warpStudentTimeGlobal = warpStudentTime;

            // Filter out unvoiced (0 Hz) segments - replace with null to break lines
            const studentPitchFiltered = studentPitch.f0_hz.map(f0 => f0 > 0 ? f0 : null);
            const referencePitchFiltered = referencePitch.f0_hz.map(f0 => f0 > 0 ? f0 : null);

            // Student trace (blue) - use WARPED time for x-axis
            const studentTrace = {
                x: studentTimeWarped,
                y: studentPitchFiltered,
                mode: 'lines',
                name: 'Student (You)',
                line: { color: '#4169e1', width: 2 },
                connectgaps: false,  // Don't connect across unvoiced segments
                hovertemplate: '<b>Student</b><br>' +
                               'Time: %{x:.3f}s (warped)<br>' +
                               'Pitch: %{y:.1f} Hz<br>' +
                               '<extra></extra>'
            };

            // Reference trace (red)
            const referenceTrace = {
                x: referencePitch.time,
                y: referencePitchFiltered,
                mode: 'lines',
                name: 'Husary Reference',
                line: { color: '#dc3545', width: 2 },
                connectgaps: false,  // Don't connect across unvoiced segments
                hovertemplate: '<b>Husary</b><br>' +
                               'Time: %{x:.3f}s<br>' +
                               'Pitch: %{y:.1f} Hz<br>' +
                               '<extra></extra>'
            };

            // Helper: interpolate pitch at specific time
            function getPitchAtTime(time, pitchData) {
                const times = pitchData.time;
                const f0s = pitchData.f0_hz;

                // Find closest time index
                for (let i = 0; i < times.length - 1; i++) {
                    if (times[i] <= time && time <= times[i+1]) {
                        // Linear interpolation
                        const alpha = (time - times[i]) / (times[i+1] - times[i]);
                        const f0_start = f0s[i];
                        const f0_end = f0s[i+1];
                        if (f0_start > 0 && f0_end > 0) {
                            return f0_start + alpha * (f0_end - f0_start);
                        } else if (f0_start > 0) {
                            return f0_start;
                        } else if (f0_end > 0) {
                            return f0_end;
                        }
                    }
                }
                // Fallback to closest
                return f0s[0] > 0 ? f0s[0] : 100;
            }

            // Student phonemes (above the line) - use WARPED time and actual pitch from contour
            const studentVoicedPhonemes = (data.student_phonemes || []).filter(p => p.mean_pitch > 0);
            const studentPhonemeTrace = {
                x: studentVoicedPhonemes.map(p => {
                    const centerTime = (p.start + p.end) / 2;
                    return warpStudentTime(centerTime);  // Warp to reference time
                }),
                y: studentVoicedPhonemes.map(p => {
                    const centerTime = (p.start + p.end) / 2;
                    return getPitchAtTime(centerTime, studentPitch);
                }),
                mode: 'markers+text',
                name: 'Student Phonemes',
                text: studentVoicedPhonemes.map(p => p.phoneme),
                textposition: 'top center',
                textfont: { size: 12, family: 'Roboto', color: '#4169e1', weight: 'bold' },
                marker: {
                    size: 10,
                    color: '#4169e1',
                    line: { width: 2, color: 'white' },
                    symbol: 'circle'
                },
                hovertemplate: '<b>Student: %{text}</b><br>' +
                               'Time: %{x:.3f}s (warped)<br>' +
                               'Pitch: %{y:.1f} Hz<br>' +
                               '<extra></extra>'
            };

            // Reference phonemes (below the line) - use actual pitch from contour, not mean
            const referenceVoicedPhonemes = (data.reference_phonemes || []).filter(p => p.mean_pitch > 0);
            const referencePhonemeTrace = {
                x: referenceVoicedPhonemes.map(p => (p.start + p.end) / 2),
                y: referenceVoicedPhonemes.map(p => {
                    const centerTime = (p.start + p.end) / 2;
                    return getPitchAtTime(centerTime, referencePitch);
                }),
                mode: 'markers+text',
                name: 'Reference Phonemes',
                text: referenceVoicedPhonemes.map(p => p.phoneme),
                textposition: 'bottom center',
                textfont: { size: 12, family: 'Roboto', color: '#dc3545', weight: 'bold' },
                marker: {
                    size: 10,
                    color: '#dc3545',
                    line: { width: 2, color: 'white' },
                    symbol: 'square'
                },
                hovertemplate: '<b>Reference: %{text}</b><br>' +
                               'Time: %{x:.3f}s<br>' +
                               'Pitch: %{y:.1f} Hz<br>' +
                               '<extra></extra>'
            };

            // Background shapes for phonemes
            const phonemeShapes = (data.student_phonemes || []).map((p, idx) => ({
                type: 'rect',
                x0: p.start,
                x1: p.end,
                y0: 0,
                y1: 1,
                yref: 'paper',
                fillcolor: idx % 2 === 0 ? 'rgba(102, 126, 234, 0.06)' : 'rgba(118, 75, 162, 0.06)',
                line: { width: 0 },
                layer: 'below'
            }));

            // Word boundaries
            const wordBoundaries = [];
            if (data.student_word_segments) {
                data.student_word_segments.forEach(seg => {
                    wordBoundaries.push({
                        type: 'line',
                        x0: seg.start_ms / 1000,
                        x1: seg.start_ms / 1000,
                        y0: 0,
                        y1: 1,
                        yref: 'paper',
                        line: { color: 'rgba(0, 0, 0, 0.2)', width: 1, dash: 'dot' },
                        layer: 'above'
                    });
                });
            }

            // Arabic word annotations
            const wordAnnotations = [];
            if (data.student_word_segments && data.student_arabic_words) {
                data.student_word_segments.forEach((seg, idx) => {
                    if (idx < data.student_arabic_words.length) {
                        const word = data.student_arabic_words[idx];
                        const arabicText = word.segments.map(s => s.text).join('');

                        wordAnnotations.push({
                            x: (seg.start_ms + seg.end_ms) / 2000,
                            y: 0,
                            yref: 'paper',
                            text: arabicText,
                            showarrow: false,
                            font: {
                                family: 'Amiri',
                                size: 18,
                                color: '#333'
                            },
                            bgcolor: 'rgba(255, 255, 255, 0.95)',
                            bordercolor: '#ddd',
                            borderwidth: 1,
                            borderpad: 4,
                            yshift: -25,
                            xanchor: 'center'
                        });
                    }
                });
            }

            const traces = [studentTrace, referenceTrace, studentPhonemeTrace, referencePhonemeTrace];

            const layout = {
                title: {
                    text: 'Pitch Comparison: Student (Blue) vs Husary (Red)',
                    font: { size: 20, color: '#667eea', family: 'Roboto' }
                },
                xaxis: {
                    title: 'Time (seconds)',
                    gridcolor: '#eee',
                    autorange: 'reversed'  // RTL
                },
                yaxis: {
                    title: 'Pitch (Hz)',
                    gridcolor: '#eee'
                },
                shapes: [...phonemeShapes, ...wordBoundaries],
                annotations: wordAnnotations,
                hovermode: 'closest',
                showlegend: true,
                legend: {
                    x: 1,
                    y: 1,
                    xanchor: 'right',
                    bgcolor: 'rgba(255, 255, 255, 0.9)',
                    bordercolor: '#ddd',
                    borderwidth: 1
                },
                margin: { l: 60, r: 20, t: 80, b: 80 },
                autosize: true
            };

            const config = {
                responsive: true,
                displayModeBar: true
            };

            Plotly.newPlot('pitchPlot', traces, layout, config).then(() => {
                window.dispatchEvent(new Event('resize'));
            });
        }

        function setupDualCursorTracking() {
            const studentPlayer = document.getElementById('studentAudioPlayer');
            const referencePlayer = document.getElementById('referenceAudioPlayer');
            const plotDiv = document.getElementById('pitchPlot');

            const studentCursor = document.getElementById('studentCursorOverlay');
            const studentDot = document.getElementById('studentCursorDot');
            const referenceCursor = document.getElementById('referenceCursorOverlay');
            const referenceDot = document.getElementById('referenceCursorDot');

            function updatePlotBounds() {
                const plotlyDiv = plotDiv.querySelector('.plotly');
                if (!plotlyDiv) return;

                const plotArea = plotlyDiv.querySelector('.plot');
                if (!plotArea) return;

                const rect = plotArea.getBoundingClientRect();
                const containerRect = plotDiv.getBoundingClientRect();

                plotBounds = {
                    left: rect.left - containerRect.left,
                    top: rect.top - containerRect.top,
                    width: rect.width,
                    height: rect.height
                };
            }

            setTimeout(updatePlotBounds, 200);

            function interpolatePitch(time, pitchData) {
                const times = pitchData.time;
                const f0s = pitchData.f0_hz;

                let left = 0, right = times.length - 1;
                while (left < right) {
                    const mid = Math.floor((left + right) / 2);
                    if (times[mid] < time) left = mid + 1;
                    else right = mid;
                }

                let targetPitch = 100;
                if (left > 0 && left < times.length) {
                    const t0 = times[left - 1];
                    const t1 = times[left];
                    const f0 = f0s[left - 1];
                    const f1 = f0s[left];

                    if (f0 > 0 && f1 > 0) {
                        const alpha = (time - t0) / (t1 - t0);
                        targetPitch = f0 + alpha * (f1 - f0);
                    } else if (f0 > 0) {
                        targetPitch = f0;
                    } else if (f1 > 0) {
                        targetPitch = f1;
                    }
                }

                return targetPitch;
            }

            function updateStudentCursor() {
                if (!plotBounds || studentPlayer.paused || studentPlayer.ended) {
                    if (!studentPlayer.paused && !studentPlayer.ended) {
                        studentAnimationFrame = requestAnimationFrame(updateStudentCursor);
                    }
                    return;
                }

                const currentTime = studentPlayer.currentTime;

                // Update plot bounds on resize
                if (Date.now() - (window.lastBoundsUpdate || 0) > 100) {
                    updatePlotBounds();
                    window.lastBoundsUpdate = Date.now();
                }
                if (!plotBounds) return;

                // Get current axis ranges from Plotly
                const plotlyDiv = document.getElementById('pitchPlot');
                const layout = plotlyDiv.layout;
                // RTL: xaxis.range[0] is MAX (right), xaxis.range[1] is MIN (left)
                const xMax = layout.xaxis.range ? layout.xaxis.range[0] : 10;
                const xMin = layout.xaxis.range ? layout.xaxis.range[1] : 0;
                const yMin = layout.yaxis.range ? layout.yaxis.range[0] : 50;
                const yMax = layout.yaxis.range ? layout.yaxis.range[1] : 400;

                // Map data coordinates to pixel coordinates
                const xRange = xMax - xMin;
                const yRange = yMax - yMin;

                const pitch = interpolatePitch(currentTime, comparisonData.student_pitch);

                // Warp student time to reference time for plot positioning
                const warpedTime = window.warpStudentTimeGlobal ? window.warpStudentTimeGlobal(currentTime) : currentTime;

                // Convert data coordinates to normalized [0,1] then to pixels
                // RTL: larger time values are on the LEFT, so we need (xMax - warpedTime) / xRange
                const xNorm = (xMax - warpedTime) / xRange;  // RTL: reversed, using WARPED time
                const yNorm = (pitch - yMin) / yRange;

                const xPos = plotBounds.left + plotBounds.width * xNorm;
                const yPos = plotBounds.top + plotBounds.height * (1 - yNorm);  // Flip Y

                studentCursor.style.left = xPos + 'px';
                studentCursor.style.top = plotBounds.top + 'px';
                studentCursor.style.height = plotBounds.height + 'px';
                studentCursor.style.display = 'block';

                studentDot.style.left = xPos + 'px';
                studentDot.style.top = yPos + 'px';
                studentDot.style.display = 'block';

                studentAnimationFrame = requestAnimationFrame(updateStudentCursor);
            }

            function updateReferenceCursor() {
                if (!plotBounds || referencePlayer.paused || referencePlayer.ended) {
                    if (!referencePlayer.paused && !referencePlayer.ended) {
                        referenceAnimationFrame = requestAnimationFrame(updateReferenceCursor);
                    }
                    return;
                }

                const currentTime = referencePlayer.currentTime;

                // Update plot bounds on resize
                if (Date.now() - (window.lastBoundsUpdate || 0) > 100) {
                    updatePlotBounds();
                    window.lastBoundsUpdate = Date.now();
                }
                if (!plotBounds) return;

                // Get current axis ranges from Plotly
                const plotlyDiv = document.getElementById('pitchPlot');
                const layout = plotlyDiv.layout;
                // RTL: xaxis.range[0] is MAX (right), xaxis.range[1] is MIN (left)
                const xMax = layout.xaxis.range ? layout.xaxis.range[0] : 10;
                const xMin = layout.xaxis.range ? layout.xaxis.range[1] : 0;
                const yMin = layout.yaxis.range ? layout.yaxis.range[0] : 50;
                const yMax = layout.yaxis.range ? layout.yaxis.range[1] : 400;

                // Map data coordinates to pixel coordinates
                const xRange = xMax - xMin;
                const yRange = yMax - yMin;

                const pitch = interpolatePitch(currentTime, comparisonData.reference_pitch);

                // Convert data coordinates to normalized [0,1] then to pixels
                // RTL: larger time values are on the LEFT, so we need (xMax - currentTime) / xRange
                const xNorm = (xMax - currentTime) / xRange;  // RTL: reversed
                const yNorm = (pitch - yMin) / yRange;

                const xPos = plotBounds.left + plotBounds.width * xNorm;
                const yPos = plotBounds.top + plotBounds.height * (1 - yNorm);  // Flip Y

                referenceCursor.style.left = xPos + 'px';
                referenceCursor.style.top = plotBounds.top + 'px';
                referenceCursor.style.height = plotBounds.height + 'px';
                referenceCursor.style.display = 'block';

                referenceDot.style.left = xPos + 'px';
                referenceDot.style.top = yPos + 'px';
                referenceDot.style.display = 'block';

                referenceAnimationFrame = requestAnimationFrame(updateReferenceCursor);
            }

            // Student player events
            studentPlayer.addEventListener('play', () => {
                updatePlotBounds();
                updateStudentCursor();
            });
            studentPlayer.addEventListener('pause', () => {
                if (studentAnimationFrame) {
                    cancelAnimationFrame(studentAnimationFrame);
                }
            });
            studentPlayer.addEventListener('ended', () => {
                studentCursor.style.display = 'none';
                studentDot.style.display = 'none';
            });

            // Reference player events
            referencePlayer.addEventListener('play', () => {
                updatePlotBounds();
                updateReferenceCursor();
            });
            referencePlayer.addEventListener('pause', () => {
                if (referenceAnimationFrame) {
                    cancelAnimationFrame(referenceAnimationFrame);
                }
            });
            referencePlayer.addEventListener('ended', () => {
                referenceCursor.style.display = 'none';
                referenceDot.style.display = 'none';
            });

            window.addEventListener('resize', updatePlotBounds);
        }

        function updatePitchExtractor() {
            // TODO: Re-analyze with new pitch extractor
            alert('Pitch extractor changed. Please re-submit your recitation to use the new extractor.');
        }

        function togglePhonemes() {
            if (!comparisonData) return;

            const showStudent = document.getElementById('showStudentPhonemes').checked;
            const showReference = document.getElementById('showReferencePhonemes').checked;

            // Update trace visibility using Plotly.restyle
            Plotly.restyle('pitchPlot', { visible: showStudent }, [2]);  // Student phonemes (trace index 2)
            Plotly.restyle('pitchPlot', { visible: showReference }, [3]);  // Reference phonemes (trace index 3)
        }

        // Initialize
        populateSurahDropdown();
    </script>
</body>
</html>

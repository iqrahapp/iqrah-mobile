# Data Architecture v2: Production Design

**Version:** 2.0.0
**Last Updated:** 2024-11-25
**Status:** Authoritative

## Executive Summary
This document defines the authoritative data architecture for the Iqrah application, version 2.0. It outlines a two-database design that separates immutable content from mutable user data, ensuring stability and safe updates. It also establishes strict contracts for Node Unique Keys (`ukeys`) and a formal stability policy to guarantee that user progress is preserved across all future content updates. The core principle is "Internal Ints, External Strings," where the application uses performant integer IDs for internal graph operations and stable string `ukeys` for all external references, including user data.

## Database Design
### Architecture Decision: 2 Databases
The application employs a two-database architecture to achieve a clean separation of concerns:

*   **`content.db`**: This is the immutable knowledge graph. It contains the Quranic text, translations, node relationships, and all other core content. It uses volatile `INTEGER` primary keys for maximum performance within the graph. This database is shipped with the application and is completely replaced during monthly content updates.
*   **`user.db`**: This database stores all mutable user-specific data, including memory states (FSRS), review history, and settings. To ensure data integrity across content updates, it **exclusively** uses stable `STRING` unique keys (`ukeys`) to reference nodes in `content.db`.

This separation allows for seamless content updates without ever touching user data, making the process safe and reliable.

## Graph Update Process
The `content.db` is treated as an ephemeral artifact. The monthly update process is as follows:
1.  A new version of the knowledge graph is generated by the Python toolchain.
2.  The new graph is packaged into a new `content.db` file.
3.  This new database file is shipped with the application update.
4.  Upon starting, the application replaces the old `content.db` with the new one.
5.  User progress in `user.db` remains untouched. The application uses the `NodeRegistry` in the new `content.db` to resolve the stable `ukeys` from `user.db` to the new, volatile integer IDs.

## Node ID Specification
The system uses two types of identifiers: internal, volatile integer IDs and external, stable string `ukeys`.

### Node Unique Key (ukey) Specification
`ukeys` are the stable string identifiers used in `user.db` and any external APIs. They are guaranteed to never change once established.

#### Content Node Formats
*   **Chapter**: `CHAPTER:{chapter_num}`
    *   Example: `CHAPTER:1`
*   **Verse**: `VERSE:{chapter_num}:{verse_num}`
    *   Example: `VERSE:1:1`
*   **Word Instance**: `WORD_INSTANCE:{chapter_num}:{verse_num}:{position}`
    *   Example: `WORD_INSTANCE:1:1:3`

**Note on `ukey` Simplification:** Formats for `WORD`, `LEMMA`, and `ROOT` are intentionally omitted. User progress is tracked only at the verse and word-instance level to simplify the learning model and reduce the surface area for potential stability violations.

#### Knowledge Node Formats
Knowledge nodes represent a specific learning axis for a content node.
*   **Format**: `{content_ukey}:{axis}`
*   **Examples**:
    *   `VERSE:1:1:memorization`
    *   `WORD_INSTANCE:1:1:3:translation`

### Enum Mappings
All enums (`NodeType`, `KnowledgeAxis`, `EdgeType`) are stored as `INTEGER`s in the database for efficiency. The authoritative string-to-integer mappings are defined in `docs/reference/enum-mappings.md`.

### Parsing and Validation Rules
*   All node `ukey` parsing and construction in the Rust codebase **must** be handled by the `iqrah-core::domain::node_id` utility module.
*   Ad-hoc string splitting or concatenation is strictly prohibited to ensure consistency.
*   The `node_id` module is the single source of truth for `ukey` formats.

## Node ID Stability Policy
### Guarantees
The **string `ukey`** for any given node, once released in a production build, **MUST NOT CHANGE**. This is the fundamental contract that protects user data.

### Enforcement
A validation step will be added to the pre-commit checks (Task 1.5) that compares the `ukeys` in a new graph build against the `ukeys` from the previous production build. Any changes (modifications or deletions) will fail the check, preventing breaking changes from being merged.

### Migration Process
In the rare event that a `ukey` must be changed, a formal migration path is required. This involves:
1.  Documenting the change in a migration file.
2.  Implementing logic in the application's startup sequence to read this file and perform a one-time `UPDATE` on the `user.db`, changing the old `ukey` to the new one.
3.  This process must be handled with extreme care and is reserved for critical bug fixes only.

## Schema Versioning
Schema versioning is managed independently for the two databases:
*   **`content.db`**: Versioning is handled at the file level. The entire database is replaced on update, and the schema is defined by the SQL migrations in `rust/crates/iqrah-storage/migrations_content/`. The application will validate the schema version on startup to ensure compatibility.
*   **`user.db`**: Versioning follows a standard migration-based approach using `sqlx-cli`. Migrations are located in `rust/crates/iqrah-storage/migrations_user/` and are applied sequentially to the user's local database file. This ensures user data is safely evolved across application updates.

## Related Documentation
*   [Database Architecture Audit](/docs/database-architecture/)
*   [Content DB Schema](/docs/content-db-schema.md)
*   [Node ID Utility Module (Task 1.3)](/docs/todo/production-ready-tasks/task-1.3-node-id-utility-module.md)
*   [Node ID Stability Validation (Task 1.5)](/docs/todo/production-ready-tasks/task-1.5-node-id-stability-validation.md)
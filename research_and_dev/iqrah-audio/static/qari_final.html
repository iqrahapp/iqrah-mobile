<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qari Tajweed Analysis</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&family=Roboto:wght@300;400;600&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: 600;
            color: #333;
            font-size: 0.9em;
        }

        select, button {
            padding: 10px 15px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
        }

        select {
            background: white;
        }

        button {
            background: #667eea;
            color: white;
            font-weight: 600;
        }

        button:hover:not(:disabled) {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        /* View Mode Toggle */
        .view-toggle {
            display: flex;
            gap: 10px;
            padding: 5px;
            background: #f0f0f0;
            border-radius: 8px;
        }

        .view-toggle button {
            padding: 8px 15px;
            border: none;
            background: transparent;
            color: #666;
            font-size: 0.9em;
        }

        .view-toggle button.active {
            background: #667eea;
            color: white;
        }

        /* Arabic Words Display (RTL) */
        .arabic-words {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            font-family: 'Amiri', serif;
            font-size: 2em;
            line-height: 2;
            direction: rtl;
        }

        .arabic-word {
            display: inline-block;
            margin: 0 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .arabic-word:hover {
            transform: scale(1.1);
        }

        .tajweed-segment {
            display: inline;
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Tajweed Legend */
        .tajweed-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Audio Player */
        .audio-player {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        audio {
            flex: 1;
            height: 50px;
        }

        /* Pitch Plot */
        #pitchPlot {
            width: 100%;
            min-height: 600px;
            border: 2px solid #eee;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2em;
        }

        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Stats */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 12px;
            border-left: 4px solid #667eea;
            text-align: center;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #333;
            font-size: 1.5em;
            font-weight: 600;
        }

        .hidden {
            display: none !important;
        }

        /* Overlay cursor - MUCH more efficient than Plotly updates */
        #cursorOverlay {
            position: absolute;
            width: 3px;
            height: 100%;
            background: linear-gradient(to bottom, transparent 0%, #ff4444 20%, #ff4444 80%, transparent 100%);
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
            transform: translateX(-50%);
            transition: none;
            will-change: left;
        }

        #cursorDot {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #ff4444;
            border: 3px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1001;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: none;
            will-change: left, top;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ“– Qari Tajweed Analysis</h1>
        <p class="subtitle">Real-time Pitch & Phoneme Segmentation with Tajweed Rules</p>

        <div class="controls">
            <div class="control-group">
                <label for="surahSelect">Surah:</label>
                <select id="surahSelect">
                    <!-- Populated dynamically -->
                </select>
            </div>

            <div class="control-group">
                <label for="ayahSelect">Ayah:</label>
                <select id="ayahSelect">
                    <!-- Populated dynamically based on surah -->
                </select>
            </div>

            <button id="analyzeBtn" style="margin-top: 20px;">ðŸ“Š Analyze</button>

            <div class="control-group" style="margin-left: 20px;">
                <label>View Mode:</label>
                <div class="view-toggle">
                    <button id="viewLine" class="active">ðŸ“ˆ Line Graph</button>
                    <button id="viewBars">ðŸ“Š Note Bars</button>
                </div>
            </div>

            <div class="control-group" style="margin-left: 20px;">
                <label>Pitch Extractor:</label>
                <select id="pitchExtractor" style="min-width: 150px;">
                    <option value="swiftf0">SwiftF0 (Fast)</option>
                    <option value="crepe-fast">CREPE-Tiny (Good)</option>
                    <option value="crepe-accurate">CREPE-Full (Best)</option>
                </select>
            </div>
        </div>

        <div id="loading" class="loading hidden">
            <div class="spinner"></div>
            <span>Analyzing...</span>
        </div>

        <div id="results" class="hidden">
            <!-- Arabic Words with Tajweed Colors -->
            <div class="arabic-words" id="arabicWords"></div>

            <!-- Tajweed Legend -->
            <div class="tajweed-legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFC87C;"></div>
                    <span>Madd (Elongation)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #64C8FF;"></div>
                    <span>Ghunnah (Nasal)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFB6C1;"></div>
                    <span>Shadda (Doubled)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #764ba2;"></div>
                    <span>Other Phonemes</span>
                </div>
            </div>

            <!-- Stats -->
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-label">Duration</div>
                    <div class="stat-value" id="statDuration">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Phonemes</div>
                    <div class="stat-value" id="statPhonemes">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Avg Pitch</div>
                    <div class="stat-value" id="statPitch">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Pitch Range</div>
                    <div class="stat-value" id="statRange">-</div>
                </div>
            </div>

            <!-- Audio Player -->
            <div class="audio-player">
                <span style="font-weight: 600; color: #667eea;">ðŸŽµ Audio:</span>
                <audio id="audioPlayer" controls></audio>
            </div>

            <!-- Pitch Plot with Real-time Cursor -->
            <div style="position: relative;">
                <div id="pitchPlot"></div>
                <div id="cursorOverlay" style="display: none;"></div>
                <div id="cursorDot" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        // Surah names (114 surahs)
        const SURAH_NAMES = [
            "Al-Fatihah", "Al-Baqarah", "Ali 'Imran", "An-Nisa", "Al-Ma'idah", "Al-An'am",
            "Al-A'raf", "Al-Anfal", "At-Tawbah", "Yunus", "Hud", "Yusuf", "Ar-Ra'd",
            "Ibrahim", "Al-Hijr", "An-Nahl", "Al-Isra", "Al-Kahf", "Maryam", "Taha",
            "Al-Anbya", "Al-Hajj", "Al-Mu'minun", "An-Nur", "Al-Furqan", "Ash-Shu'ara",
            "An-Naml", "Al-Qasas", "Al-'Ankabut", "Ar-Rum", "Luqman", "As-Sajdah",
            "Al-Ahzab", "Saba", "Fatir", "Ya-Sin", "As-Saffat", "Sad", "Az-Zumar",
            "Ghafir", "Fussilat", "Ash-Shuraa", "Az-Zukhruf", "Ad-Dukhan", "Al-Jathiyah",
            "Al-Ahqaf", "Muhammad", "Al-Fath", "Al-Hujurat", "Qaf", "Adh-Dhariyat",
            "At-Tur", "An-Najm", "Al-Qamar", "Ar-Rahman", "Al-Waqi'ah", "Al-Hadid",
            "Al-Mujadila", "Al-Hashr", "Al-Mumtahanah", "As-Saf", "Al-Jumu'ah",
            "Al-Munafiqun", "At-Taghabun", "At-Talaq", "At-Tahrim", "Al-Mulk",
            "Al-Qalam", "Al-Haqqah", "Al-Ma'arij", "Nuh", "Al-Jinn", "Al-Muzzammil",
            "Al-Muddaththir", "Al-Qiyamah", "Al-Insan", "Al-Mursalat", "An-Naba",
            "An-Nazi'at", "Abasa", "'Adiyat", "At-Takwir", "Al-Infitar", "Al-Mutaffifin",
            "Al-Inshiqaq", "Al-Buruj", "At-Tariq", "Al-A'la", "Al-Ghashiyah", "Al-Fajr",
            "Al-Balad", "Ash-Shams", "Al-Layl", "Ad-Duhaa", "Ash-Sharh", "At-Tin",
            "Al-'Alaq", "Al-Qadr", "Al-Bayyinah", "Az-Zalzalah", "Al-'Adiyat",
            "Al-Qari'ah", "At-Takathur", "Al-'Asr", "Al-Humazah", "Al-Fil", "Quraysh",
            "Al-Ma'un", "Al-Kawthar", "Al-Kafirun", "An-Nasr", "Al-Masad", "Al-Ikhlas",
            "Al-Falaq", "An-Nas"
        ];

        // Ayah counts per surah
        const AYAH_COUNTS = [
            7, 286, 200, 176, 120, 165, 206, 75, 129, 109, 123, 111, 43, 52, 99, 128,
            111, 110, 98, 135, 112, 78, 118, 64, 77, 227, 93, 88, 69, 60, 34, 30,
            73, 54, 45, 83, 182, 88, 75, 85, 54, 53, 89, 59, 37, 35, 38, 29, 18,
            45, 60, 49, 62, 55, 78, 96, 29, 22, 24, 13, 14, 11, 11, 18, 12, 12,
            30, 52, 52, 44, 28, 28, 20, 56, 40, 31, 50, 40, 46, 42, 29, 19, 36,
            25, 22, 17, 19, 26, 30, 20, 15, 21, 11, 8, 8, 19, 5, 8, 8, 11, 11,
            8, 3, 9, 5, 4, 7, 3, 6, 3, 5, 4, 5, 6
        ];

        const analyzeBtn = document.getElementById('analyzeBtn');
        const surahSelect = document.getElementById('surahSelect');
        const ayahSelect = document.getElementById('ayahSelect');
        const loading = document.getElementById('loading');
        const results = document.getElementById('results');
        const audioPlayer = document.getElementById('audioPlayer');
        const arabicWords = document.getElementById('arabicWords');
        const viewLineBtn = document.getElementById('viewLine');
        const viewBarsBtn = document.getElementById('viewBars');

        let currentData = null;
        let animationFrameId = null;
        let viewMode = 'line'; // 'line' or 'bars'
        let currentPitchExtractor = 'swiftf0';

        // Populate surah dropdown
        for (let i = 1; i <= 114; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = `${i} - ${SURAH_NAMES[i - 1]}`;
            surahSelect.appendChild(option);
        }

        // Update ayah dropdown when surah changes
        surahSelect.addEventListener('change', () => {
            const surahNum = parseInt(surahSelect.value);
            const ayahCount = AYAH_COUNTS[surahNum - 1];

            ayahSelect.innerHTML = '';
            for (let i = 1; i <= ayahCount; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                ayahSelect.appendChild(option);
            }
        });

        // Initialize ayah dropdown for first surah
        surahSelect.dispatchEvent(new Event('change'));

        // View mode toggle
        viewLineBtn.addEventListener('click', () => {
            viewMode = 'line';
            viewLineBtn.classList.add('active');
            viewBarsBtn.classList.remove('active');
            if (currentData) plotVisualization(currentData);
        });

        viewBarsBtn.addEventListener('click', () => {
            viewMode = 'bars';
            viewBarsBtn.classList.add('active');
            viewLineBtn.classList.remove('active');
            if (currentData) plotVisualization(currentData);
        });

        analyzeBtn.addEventListener('click', async () => {
            const surah = surahSelect.value;
            const ayah = ayahSelect.value;

            loading.classList.remove('hidden');
            results.classList.add('hidden');
            analyzeBtn.disabled = true;

            try {
                const pitchExtractor = document.getElementById('pitchExtractor').value;
                const response = await fetch(`/api/analyze/${surah}/${ayah}?pitch_extractor=${pitchExtractor}`);
                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Analysis failed');
                }

                currentData = data;

                console.log('ðŸ“Š Received data:', {
                    phonemes: data.phonemes.length,
                    arabic_words: data.arabic_words?.length,
                    word_segments: data.word_segments?.length
                });

                // Update stats
                document.getElementById('statDuration').textContent = data.duration.toFixed(2) + 's';
                document.getElementById('statPhonemes').textContent = data.phonemes.length;

                const voicedPitch = data.pitch.f0_hz.filter(f => f > 0);
                const avgPitch = voicedPitch.reduce((a, b) => a + b, 0) / voicedPitch.length;
                const minPitch = Math.min(...voicedPitch);
                const maxPitch = Math.max(...voicedPitch);

                document.getElementById('statPitch').textContent = avgPitch.toFixed(1) + ' Hz';
                document.getElementById('statRange').textContent =
                    minPitch.toFixed(0) + '-' + maxPitch.toFixed(0) + ' Hz';

                // Display Arabic words with Tajweed colors
                displayArabicWords(data.arabic_words);

                // Set audio
                audioPlayer.src = data.audio_url;

                // Plot visualization
                plotVisualization(data);

                // Setup smooth real-time cursor
                setupSmoothCursor();

                loading.classList.add('hidden');
                results.classList.remove('hidden');

                // Force resize to fix width issue
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                }, 100);

            } catch (error) {
                console.error('Error:', error);
                alert('Analysis failed: ' + error.message);
                loading.classList.add('hidden');
            } finally {
                analyzeBtn.disabled = false;
            }
        });

        function displayArabicWords(words) {
            arabicWords.innerHTML = '';

            for (const word of words) {
                const wordSpan = document.createElement('span');
                wordSpan.className = 'arabic-word';

                for (const seg of word.segments) {
                    const segSpan = document.createElement('span');
                    segSpan.className = 'tajweed-segment';
                    segSpan.textContent = seg.text;
                    if (seg.tajweed_class) {
                        segSpan.style.backgroundColor = seg.color;
                        segSpan.title = seg.tajweed_class;
                    }
                    wordSpan.appendChild(segSpan);
                }

                // Add click handler to seek to word
                wordSpan.dataset.startMs = word.segments[0]?.start_ms || 0;
                wordSpan.addEventListener('click', () => {
                    const wordStartS = parseFloat(wordSpan.dataset.startMs) / 1000;
                    audioPlayer.currentTime = wordStartS;
                    if (audioPlayer.paused) {
                        audioPlayer.play();
                    }
                });

                arabicWords.appendChild(wordSpan);
            }
        }

        let lastPitch = 100;  // For smoothing
        const SMOOTHING_FACTOR = 0.3;  // Lower = smoother

        function interpolatePitch(time, pitchData) {
            const times = pitchData.time;
            const f0s = pitchData.f0_hz;

            // Binary search
            let left = 0, right = times.length - 1;
            while (left < right) {
                const mid = Math.floor((left + right) / 2);
                if (times[mid] < time) left = mid + 1;
                else right = mid;
            }

            // Linear interpolation
            let targetPitch = 100;
            if (left > 0 && left < times.length) {
                const t0 = times[left - 1];
                const t1 = times[left];
                const f0 = f0s[left - 1];
                const f1 = f0s[left];

                if (f0 > 0 && f1 > 0) {
                    const alpha = (time - t0) / (t1 - t0);
                    targetPitch = f0 + alpha * (f1 - f0);
                } else if (f0 > 0) {
                    targetPitch = f0;
                } else if (f1 > 0) {
                    targetPitch = f1;
                } else {
                    targetPitch = f0s[left] > 0 ? f0s[left] : 100;
                }
            } else {
                targetPitch = f0s[left] > 0 ? f0s[left] : 100;
            }

            // Exponential smoothing to remove jitter
            lastPitch = lastPitch + SMOOTHING_FACTOR * (targetPitch - lastPitch);
            return lastPitch;
        }

        function smoothPitchData(pitchData, windowMs = 50) {
            // Smooth pitch using moving average to reduce "noise" for bar view
            const times = pitchData.time;
            const f0s = pitchData.f0_hz;
            const smoothed = [];

            for (let i = 0; i < times.length; i++) {
                const currentTime = times[i];
                const windowStart = currentTime - windowMs / 1000;
                const windowEnd = currentTime + windowMs / 1000;

                const values = [];
                for (let j = 0; j < times.length; j++) {
                    if (times[j] >= windowStart && times[j] <= windowEnd && f0s[j] > 0) {
                        values.push(f0s[j]);
                    }
                }

                if (values.length > 0) {
                    smoothed.push(values.reduce((a, b) => a + b) / values.length);
                } else {
                    smoothed.push(f0s[i]);
                }
            }

            return smoothed;
        }

        function plotVisualization(data) {
            let pitchTrace;

            if (viewMode === 'bars') {
                // Bar view: Detect pitch level changes (note transitions)
                // Use outlier detection to break segments when pitch changes level
                
                const times = data.pitch.time;
                const f0s = data.pitch.f0_hz;
                
                const MIN_SEGMENT_DURATION = 0.06; // 60ms minimum
                const OUTLIER_THRESHOLD = 2.5; // Standard deviations
                const WINDOW_SIZE = 5; // Look at recent samples
                
                const segments = [];
                let i = 0;
                
                while (i < times.length) {
                    // Skip unvoiced
                    while (i < times.length && f0s[i] === 0) i++;
                    if (i >= times.length) break;
                    
                    // Start new segment
                    const segStart = times[i];
                    const pitchSamples = [f0s[i]];
                    let segEnd = segStart;
                    i++;
                    
                    // Extend segment until we detect a level change
                    while (i < times.length && f0s[i] > 0) {
                        const currentPitch = f0s[i];
                        
                        // Calculate stats of recent window
                        const windowStart = Math.max(0, pitchSamples.length - WINDOW_SIZE);
                        const window = pitchSamples.slice(windowStart);
                        const mean = window.reduce((a,b) => a+b) / window.length;
                        const variance = window.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / window.length;
                        const stdDev = Math.sqrt(variance);
                        
                        // Check if current pitch is an outlier (level change detected)
                        const zScore = stdDev > 0 ? Math.abs(currentPitch - mean) / stdDev : 0;
                        
                        if (zScore > OUTLIER_THRESHOLD && pitchSamples.length > 3) {
                            // Level change detected! End this segment
                            break;
                        }
                        
                        pitchSamples.push(currentPitch);
                        segEnd = times[i];
                        i++;
                    }
                    
                    // Only add segment if long enough
                    if (segEnd - segStart >= MIN_SEGMENT_DURATION && pitchSamples.length > 2) {
                        // Use median instead of mean (more robust to outliers)
                        const sorted = [...pitchSamples].sort((a,b) => a-b);
                        const median = sorted[Math.floor(sorted.length / 2)];
                        
                        segments.push({
                            start: segStart,
                            end: segEnd,
                            pitch: median,
                            samples: pitchSamples.length
                        });
                    }
                }
                
                console.log(`ðŸ“Š Detected ${segments.length} pitch levels (note segments)`);
                
                // Map to phonemes for labeling
                function getPhonemeAtTime(time) {
                    for (const p of data.phonemes) {
                        if (time >= p.start && time <= p.end) return p;
                    }
                    return null;
                }
                
                // Build traces
                const xData = [];
                const yData = [];
                const colors = [];
                const texts = [];
                const widths = [];
                
                segments.forEach(seg => {
                    const midTime = (seg.start + seg.end) / 2;
                    const phoneme = getPhonemeAtTime(midTime);
                    const label = phoneme ? phoneme.phoneme : '';
                    const tajweed = phoneme ? phoneme.tajweed_rule : null;
                    
                    // Color by Tajweed
                    const color = tajweed === 'madd' ? '#FFC87C' :
                                 tajweed === 'ghunnah' ? '#64C8FF' :
                                 tajweed === 'shadda' ? '#FFB6C1' : '#667eea';
                    
                    // Add line segment
                    xData.push(seg.start, seg.end, null);
                    yData.push(seg.pitch, seg.pitch, null);
                    colors.push(color, color, 'transparent');
                    texts.push(label, label, '');
                });

                pitchTrace = {
                    x: xData,
                    y: yData,
                    mode: 'lines+markers',
                    name: 'Note Levels',
                    line: { 
                        color: '#667eea',
                        width: 6
                    },
                    marker: {
                        size: 8,
                        color: colors,
                        line: { width: 2, color: 'white' }
                    },
                    text: texts,
                    hovertemplate: '<b>%{text}</b><br>' +
                                   'Pitch: %{y:.1f} Hz<br>' +
                                   '<extra></extra>'
                };
            } else {
                // Line view: Traditional pitch contour
                pitchTrace = {
                    x: data.pitch.time,
                    y: data.pitch.f0_hz,
                    mode: 'lines',
                    name: 'Pitch Contour',
                    line: { color: '#667eea', width: 2 },
                    hovertemplate: '<b>Pitch</b><br>' +
                                   'Time: %{x:.3f}s<br>' +
                                   'Frequency: %{y:.1f} Hz<br>' +
                                   '<extra></extra>'
                };
            }

            // Phoneme markers
            const voicedPhonemes = data.phonemes.filter(p => p.mean_pitch > 0);

            const phonemeTrace = {
                x: voicedPhonemes.map(p => (p.start + p.end) / 2),
                y: voicedPhonemes.map(p => p.mean_pitch),
                mode: 'markers+text',
                name: 'Phonemes',
                text: voicedPhonemes.map(p => p.phoneme),
                textposition: 'top center',
                textfont: { size: 14, family: 'Roboto', color: '#000', weight: 'bold' },
                marker: {
                    size: 12,
                    color: voicedPhonemes.map(p => {
                        const rule = p.tajweed_rule;
                        if (rule === 'madd') return '#FFC87C';
                        if (rule === 'ghunnah') return '#64C8FF';
                        if (rule === 'shadda') return '#FFB6C1';
                        return '#764ba2';
                    }),
                    line: { width: 2, color: 'white' }
                },
                hovertemplate: '<b>%{text}</b><br>' +
                               'Time: %{x:.3f}s<br>' +
                               'Pitch: %{y:.1f} Hz<br>' +
                               '<extra></extra>'
            };



            // Background shapes for phonemes
            const phonemeShapes = data.phonemes.map((p, idx) => ({
                type: 'rect',
                x0: p.start,
                x1: p.end,
                y0: 0,
                y1: 1,
                yref: 'paper',
                fillcolor: idx % 2 === 0 ? 'rgba(102, 126, 234, 0.06)' : 'rgba(118, 75, 162, 0.06)',
                line: { width: 0 },
                layer: 'below'
            }));

            // Word segment boundaries (vertical lines)
            const wordBoundaries = [];
            if (data.word_segments) {
                data.word_segments.forEach(seg => {
                    wordBoundaries.push({
                        type: 'line',
                        x0: seg.start_ms / 1000,
                        x1: seg.start_ms / 1000,
                        y0: 0,
                        y1: 1,
                        yref: 'paper',
                        line: { color: 'rgba(0, 0, 0, 0.2)', width: 1, dash: 'dot' },
                        layer: 'above'
                    });
                });
            }

            // Annotations for Arabic words below X-axis (RTL)
            const wordAnnotations = [];
            if (data.word_segments && data.arabic_words) {
                data.word_segments.forEach((seg, idx) => {
                    if (idx < data.arabic_words.length) {
                        const word = data.arabic_words[idx];
                        const arabicText = word.segments.map(s => s.text).join('');

                        wordAnnotations.push({
                            x: (seg.start_ms + seg.end_ms) / 2000,
                            y: 0,
                            yref: 'paper',
                            text: arabicText,
                            showarrow: false,
                            font: {
                                family: 'Amiri',
                                size: 18,
                                color: '#333'
                            },
                            bgcolor: 'rgba(255, 255, 255, 0.8)',
                            bordercolor: '#ddd',
                            borderwidth: 1,
                            borderpad: 4,
                            yshift: -25,
                            xanchor: 'center'
                        });
                    }
                });
            }

            const traces = viewMode === 'bars'
                ? [pitchTrace]  // No cursor trace - using DOM overlay
                : [pitchTrace, phonemeTrace];

            const layout = {
                title: {
                    text: viewMode === 'bars'
                        ? 'Pitch Notes (Simplified View)'
                        : 'Pitch Contour with Phoneme Segmentation',
                    font: { size: 20, color: '#667eea', family: 'Roboto' }
                },
                xaxis: {
                    title: 'Time (seconds)',
                    gridcolor: '#eee',
                    autorange: 'reversed'  // RTL: Reverse X-axis
                },
                yaxis: {
                    title: 'Pitch (Hz)',
                    gridcolor: '#eee'
                },
                shapes: [...phonemeShapes, ...wordBoundaries],
                annotations: wordAnnotations,
                hovermode: 'closest',
                showlegend: true,
                legend: {
                    x: 1,
                    y: 1,
                    xanchor: 'right',
                    bgcolor: 'rgba(255, 255, 255, 0.9)',
                    bordercolor: '#ddd',
                    borderwidth: 1
                },
                margin: { l: 60, r: 20, t: 80, b: 80 },
                autosize: true
            };

            const config = {
                responsive: true,
                displayModeBar: true
            };

            Plotly.newPlot('pitchPlot', traces, layout, config).then(() => {
                // Force one more resize after plot is created
                window.dispatchEvent(new Event('resize'));
            });
        }

        let plotBounds = null;

        function setupSmoothCursor() {
            if (!currentData) return;

            const cursorLine = document.getElementById('cursorOverlay');
            const cursorDot = document.getElementById('cursorDot');
            const plotDiv = document.getElementById('pitchPlot');

            // Get plot bounds once
            function updatePlotBounds() {
                const plotlyDiv = plotDiv.querySelector('.plotly');
                if (!plotlyDiv) return;
                
                const plotArea = plotlyDiv.querySelector('.plot');
                if (!plotArea) return;

                const rect = plotArea.getBoundingClientRect();
                const containerRect = plotDiv.getBoundingClientRect();
                
                plotBounds = {
                    left: rect.left - containerRect.left,
                    top: rect.top - containerRect.top,
                    width: rect.width,
                    height: rect.height
                };
            }

            // Update bounds after plot is ready
            setTimeout(updatePlotBounds, 200);

            // Cancel any existing animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            function updateCursor() {
                if (!plotBounds || audioPlayer.paused || audioPlayer.ended) {
                    if (!audioPlayer.paused && !audioPlayer.ended) {
                        animationFrameId = requestAnimationFrame(updateCursor);
                    }
                    return;
                }

                const currentTime = audioPlayer.currentTime;
                const duration = currentData.duration;

                // Calculate position (RTL: reversed x-axis)
                const progress = currentTime / duration;
                const xPos = plotBounds.left + plotBounds.width * (1 - progress);  // RTL

                // Get pitch for dot position - use Plotly's Y-axis scale
                const pitch = interpolatePitch(currentTime, currentData.pitch);
                
                // Get Y-axis range from Plotly layout
                const plotlyDiv = document.getElementById('pitchPlot');
                const layout = plotlyDiv.layout;
                const yaxis = layout.yaxis;
                const yMin = yaxis.range ? yaxis.range[0] : 50;
                const yMax = yaxis.range ? yaxis.range[1] : 400;
                const yRange = yMax - yMin;
                
                // Map pitch to Y position
                const pitchProgress = yRange > 0 ? (pitch - yMin) / yRange : 0.5;
                const yPos = plotBounds.top + plotBounds.height * (1 - pitchProgress);

                // Update DOM - MUCH faster than Plotly!
                cursorLine.style.left = xPos + 'px';
                cursorLine.style.top = plotBounds.top + 'px';
                cursorLine.style.height = plotBounds.height + 'px';
                cursorLine.style.display = 'block';

                cursorDot.style.left = xPos + 'px';
                cursorDot.style.top = yPos + 'px';
                cursorDot.style.display = 'block';

                animationFrameId = requestAnimationFrame(updateCursor);
            }

            // Start animation loop
            audioPlayer.addEventListener('play', () => {
                updatePlotBounds();  // Refresh bounds
                updateCursor();
            });
            
            audioPlayer.addEventListener('pause', () => {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
            });

            audioPlayer.addEventListener('ended', () => {
                cursorLine.style.display = 'none';
                cursorDot.style.display = 'none';
            });

            audioPlayer.addEventListener('seeked', () => {
                if (!audioPlayer.paused) {
                    updatePlotBounds();
                }
            });

            // Update bounds on window resize
            window.addEventListener('resize', () => {
                updatePlotBounds();
            });
        }

        // Auto-analyze first ayah on load
        window.addEventListener('load', () => {
            setTimeout(() => analyzeBtn.click(), 500);
        });
    </script>
</body>
</html>
